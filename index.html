<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Nin Online Tournaments - Hawk Server</title>
    <link rel="icon" type="image/png" href="./icon.png" id="dynamic-favicon">
    <script src="https://cdn.tailwindcss.com"></script>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <style>
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; }
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #475569; }
        .scrollbar-hide::-webkit-scrollbar { display: none; }
        .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
    </style>
</head>
<body class="bg-slate-950 text-slate-100 font-sans">
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-app.js";
        import { getAnalytics } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-analytics.js";
        import { getAuth, signInWithEmailAndPassword, signOut, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-auth.js";
        import { getFirestore, collection, getDocs, addDoc, writeBatch, doc, query, orderBy, limit, getDoc, setDoc } from "https://www.gstatic.com/firebasejs/10.8.0/firebase-firestore.js";

        // --- FIREBASE CONFIG ---
        const firebaseConfig = {
            apiKey: "AIzaSyAtgtLxebRErfAmuEbBH57E8O46eF9xDA0",
            authDomain: "ninranking.firebaseapp.com",
            projectId: "ninranking",
            storageBucket: "ninranking.firebasestorage.app",
            messagingSenderId: "566414381119",
            appId: "1:566414381119:web:f59754c048df28a9eea88a",
            measurementId: "G-V9V42ZM55P"
        };

        const app = initializeApp(firebaseConfig);
        const analytics = getAnalytics(app);
        const auth = getAuth(app);
        const db = getFirestore(app);

        const { useState, useEffect, useMemo, useRef, useLayoutEffect } = React;

        const useLockBodyScroll = () => {
            useLayoutEffect(() => {
                const originalStyle = window.getComputedStyle(document.body).overflow;
                document.body.style.overflow = 'hidden';
                return () => { document.body.style.overflow = originalStyle; };
            }, []);
        };

        // --- ICONS ---
        const IconBase = ({ children, className, ...props }) => (<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2" strokeLinecap="round" strokeLinejoin="round" className={className} {...props}>{children}</svg>);
        const Trophy = (props) => <IconBase {...props}><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></IconBase>;
        const Swords = (props) => <IconBase {...props}><polyline points="14.5 17.5 3 6 3 3 6 3 17.5 14.5"/><line x1="13" x2="19" y1="19" y2="13"/><line x1="16" x2="20" y1="16" y2="20"/><line x1="19" x2="21" y1="21" y2="19"/></IconBase>;
        const Users = (props) => <IconBase {...props}><path d="M16 21v-2a4 4 0 0 0-4-4H6a4 4 0 0 0-4 4v2"/><circle cx="9" cy="7" r="4"/><path d="M22 21v-2a4 4 0 0 0-3-3.87"/><path d="M16 3.13a4 4 0 0 1 0 7.75"/></IconBase>;
        const Medal = (props) => <IconBase {...props}><circle cx="12" cy="17" r="5"/><path d="M9 17v-8"/><path d="M15 17v-8"/><path d="M9 17h6"/><path d="M12 2v5"/><path d="M12 2l-4 5"/><path d="M12 2l4 5"/></IconBase>;
        const TrendingUp = (props) => <IconBase {...props}><polyline points="22 7 13.5 15.5 8.5 10.5 2 17"/><polyline points="16 7 22 7 22 13"/></IconBase>;
        const Search = (props) => <IconBase {...props}><circle cx="11" cy="11" r="8"/><path d="m21 21-4.3-4.3"/></IconBase>;
        const Calendar = (props) => <IconBase {...props}><rect width="18" height="18" x="3" y="4" rx="2" ry="2"/><line x1="16" x2="16" y1="2" y2="6"/><line x1="8" x2="8" y1="2" y2="6"/><line x1="3" x2="21" y1="10" y2="10"/></IconBase>;
        const Clock = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><polyline points="12 6 12 12 16 14"/></IconBase>;
        const XIcon = (props) => <IconBase {...props}><path d="M18 6 6 18"/><path d="m6 6 12 12"/></IconBase>;
        const Filter = (props) => <IconBase {...props}><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"/></IconBase>;
        const ChevronDown = (props) => <IconBase {...props}><path d="m6 9 6 6 6-6"/></IconBase>;
        const ChevronUp = (props) => <IconBase {...props}><path d="m18 15-6-6-6 6"/></IconBase>;
        const ChevronLeft = (props) => <IconBase {...props}><path d="m15 18-6-6 6-6"/></IconBase>;
        const ChevronRight = (props) => <IconBase {...props}><path d="m9 18 6-6-6-6"/></IconBase>;
        const ArrowRight = (props) => <IconBase {...props}><path d="M5 12h14"/><path d="m12 5 7 7-7 7"/></IconBase>;
        const Loader2 = (props) => <IconBase {...props}><path d="M21 12a9 9 0 1 1-6.219-8.56"/></IconBase>;
        const AlertCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="8" y2="12"/><line x1="12" x2="12.01" y1="16" y2="16"/></IconBase>;
        const ServerIcon = (props) => <IconBase {...props}><rect x="2" y="2" width="20" height="8" rx="2" ry="2"/><rect x="2" y="14" width="20" height="8" rx="2" ry="2"/><line x1="6" x2="6.01" y1="6" y2="6"/><line x1="6" x2="6.01" y1="18" y2="18"/></IconBase>;
        const InfoIcon = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="12" x2="12" y1="16" y2="12"/><line x1="12" x2="12.01" y1="8" y2="8"/></IconBase>;
        const Menu = (props) => <IconBase {...props}><line x1="4" x2="20" y1="12" y2="12"/><line x1="4" x2="20" y1="6" y2="6"/><line x1="4" x2="20" y1="18" y2="18"/></IconBase>;
        const TrendingDown = (props) => <IconBase {...props}><polyline points="22 17 13.5 8.5 8.5 13.5 2 7"/><polyline points="16 17 22 17 22 11"/></IconBase>;
        const ShieldCheck = (props) => <IconBase {...props}><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"/><path d="m9 12 2 2 4-4"/></IconBase>;
        const GitBranch = (props) => <IconBase {...props}><line x1="6" x2="6" y1="3" y2="15"/><circle cx="18" cy="6" r="3"/><circle cx="6" cy="18" r="3"/><path d="M18 9a9 9 0 0 1-9 9"/></IconBase>;
        const HelpCircle = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></IconBase>;
        const BookOpen = (props) => <IconBase {...props}><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"/><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"/></IconBase>;
        const MapIcon = (props) => <IconBase {...props}><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"/><line x1="8" y1="2" x2="8" y2="18"/><line x1="16" y1="6" x2="16" y2="22"/></IconBase>;
        const Layers = (props) => <IconBase {...props}><path d="m12.83 2.18a2 2 0 0 0-1.66 0L2.6 6.08a1 1 0 0 0 0 1.83l8.58 3.91a2 2 0 0 0 1.66 0l8.58-3.9a1 1 0 0 0 0-1.83Z"/><path d="m22 17.65-9.17 4.16a2 2 0 0 1-1.66 0L2 17.65"/><path d="m22 12.65-9.17 4.16a2 2 0 0 1-1.66 0L2 12.65"/></IconBase>;
        const AlertTriangle = (props) => <IconBase {...props}><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"/><line x1="12" y1="9" x2="12" y2="13"/><line x1="12" y1="17" x2="12.01" y2="17"/></IconBase>;
        const Crosshair = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="22" y1="12" x2="18" y2="12"/><line x1="6" y1="12" x2="2" y2="12"/><line x1="12" y1="6" x2="12" y2="2"/><line x1="12" y1="22" x2="12" y2="18"/></IconBase>;
        const Skull = (props) => <IconBase {...props}><circle cx="9" cy="12" r="1"/><circle cx="15" cy="12" r="1"/><path d="M8 20v2h8v-2"/><path d="m12.5 17-.5-1-.5 1h1z"/><path d="M16 20a2 2 0 0 0 1.56-3.25 8 8 0 1 0-11.12 0A2 2 0 0 0 8 20"/></IconBase>;
        const Award = (props) => <IconBase {...props}><circle cx="12" cy="8" r="7"/><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"/></IconBase>;
        const ShareIcon = (props) => <IconBase {...props}><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"/><polyline points="16 6 12 2 8 6"/><line x1="12" x2="12" y1="2" y2="15"/></IconBase>;
        const Flame = (props) => <IconBase {...props} fill="currentColor"><path d="M12 2c0 0-3 2.5-3 6 0 2 1.5 3 1.5 5S9 19 12 19s4.5-3.5 4.5-6-1.5-3-1.5-5-3-6-3-6zm0 15c-1.5 0-2.5-1.5-2.5-3.5S10.5 11 12 11s2.5 1.5 2.5 2.5S13.5 17 12 17z" /><path d="M9.5 9c0 0-1.5 1.5-1.5 3.5S9 16 11 16s2.5-1.5 2.5-3-2-5-4-4z" opacity="0.6"/></IconBase>;
        const Star = (props) => <IconBase {...props}><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2" fill="currentColor" fillOpacity="0.2" /></IconBase>;
        const ShurikenIcon = (props) => <IconBase {...props}><path d="M12 2L14.5 9.5L22 12L14.5 14.5L12 22L9.5 14.5L2 12L9.5 9.5L12 2Z" fill="currentColor" fillOpacity="0.2" /></IconBase>;
        const ScrollIcon = (props) => <IconBase {...props}><path d="M19 4H9C7.89543 4 7 4.89543 7 6V20C7 21.1046 7.89543 22 9 22H19C20.1046 22 21 21.1046 21 20V6C21 4.89543 20.1046 4 19 4Z" /><path d="M5 15H4C3.44772 15 3 14.5523 3 14V8C3 7.44772 3.44772 7 4 7H5" /><path d="M15 12H19" /><path d="M15 16H19" /><path d="M15 8H19" /></IconBase>;
        const Globe = (props) => <IconBase {...props}><circle cx="12" cy="12" r="10"/><line x1="2" x2="22" y1="12" y2="12"/><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"/></IconBase>;
        const LogIn = (props) => <IconBase {...props}><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"/><polyline points="10 17 15 12 10 7"/><line x1="15" x2="3" y1="12" y2="12"/></IconBase>;
        const LogOut = (props) => <IconBase {...props}><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"/><polyline points="16 17 21 12 16 7"/><line x1="21" x2="9" y1="12" y2="12"/></IconBase>;
        const UploadCloud = (props) => <IconBase {...props}><path d="M4 14.899A7 7 0 1 1 15.71 8h1.79a4.5 4.5 0 0 1 2.5 8.242"/><path d="M12 12v9"/><path d="m16 16-4-4-4 4"/></IconBase>;

        // --- CONFIG ---
        const CUSTOM_ICON_URL = './icon.png'; 
        const PRIORITY_MODES = ['Auto1v1', 'Auto2v2', 'Auto3v3', 'DBE1v1', 'DBE2v2'];
        
        const STYLE_MAP = {
            'Fogo': 'bg-red-500/20 text-red-400 border-red-500/30', 'Água': 'bg-blue-500/20 text-blue-400 border-blue-500/30', 'Terra': 'bg-amber-700/20 text-amber-500 border-amber-700/30',
            'Vento': 'bg-emerald-500/20 text-emerald-400 border-emerald-500/30', 'Raio': 'bg-yellow-500/20 text-yellow-400 border-yellow-500/30', 'Médico': 'bg-pink-500/20 text-pink-400 border-pink-500/30',
            'Arma': 'bg-slate-500/20 text-slate-400 border-slate-500/30', 'Taijutsu': 'bg-orange-500/20 text-orange-400 border-orange-500/30', 'Leque': 'bg-cyan-500/20 text-cyan-400 border-cyan-500/30',
            'Bolha': 'bg-indigo-400/20 text-indigo-300 border-indigo-400/30', 'Punho Gentil': 'bg-white/10 text-slate-200 border-white/20', 'Folha': 'text-green-400',
            'Areia': 'text-yellow-500', 'Névoa': 'text-blue-400', 'Renegado Folha': 'text-slate-400', 'Renegado Areia': 'text-slate-400', 'Renegado Névoa': 'text-slate-400',
        };

        const TRANSLATIONS = {
            pt: {
                server: "Servidor: Hawk", to: "até",
                login_title: "Área Administrativa", login_text: "Faça login para gerenciar dados.", login_btn: "Entrar", logout: "Sair", upload_data: "Enviar Dados",
                search_placeholder: "Buscar jogador...", ranking: "Ranking", versus: "Versus", tournaments: "Torneios", masteries: "Maestrias", villages: "Vilas",
                others: "Outros", current_month: "Este Mês", day: "Últimas 24h", week: "Última Semana", specific_month: "Selecionar Mês", all: "Todo o Período", default_desc: "Estatísticas detalhadas para este modo de jogo específico.",
                player1: "Jogador 1", player2: "Jogador 2", no_match: "Nenhum confronto encontrado entre estes jogadores.", winners: "Vencedores", losers: "Perdedores",
                victory_p1: "VITÓRIA J1", defeat_p1: "DERROTA J1", see_tournament: "Ver Torneio", active_players: "Jogadores Ativos", total_battles: "Batalhas Totais", most_wins: "Mais Vitórias", most_losses: "Mais Derrotas",
                player: "Jogador", t_wins: "T. Vencidos", t_played: "T. Jogados", wins: "Vitórias", losses: "Derrotas", battles: "Partidas", win_rate: "Win Rate",
                no_player_found: "Nenhum jogador encontrado para este filtro.", date: "Data", tournament: "Torneio", time: "Horário", no_tournament_found: "Nenhum torneio encontrado para este filtro.",
                manual_warning: "Atenção: Dados Manuais", manual_warning_text: "Os dados desta seção são atualizados manualmente consultando o Bingo Book. Podem ocorrer desatualizações devido a resets de conta ou mudanças de vila. Caso encontre erros, avise no Discord. A lista será atualizada com o tempo.",
                ranking_masteries: "Ranking de Maestrias", ranking_masteries_sub: "Estatísticas acumuladas por maestria.", combined: "Combinadas", individual: "Individuais",
                mastery: "Maestria", total_wins: "Total Vitórias", no_mastery_data: "Nenhum dado de maestria encontrado.", ranking_villages: "Ranking de Vilas", ranking_villages_sub: "Estatísticas acumuladas por vila.",
                village: "Vila", no_village_data: "Nenhum dado de vila encontrado.", files_loaded: "Dados carregados do Firebase",
                // Modals
                how_to_use: "Como usar o site", functionalities: "Funcionalidades", features_list_1: "Ranking: Veja os melhores jogadores do servidor. Clique em um nome para ver o histórico de partidas e gráficos de desempenho.",
                features_list_2: "Torneios: Acesse a lista de torneios passados. Clique em um torneio para visualizar as chaves (brackets) e o progresso das lutas.", features_list_3: "Filtros: Use os filtros de modo (Geral, Ranked, etc.) e data para refinar os resultados.",
                features_list_4: "Versus: Compare o desempenho direto entre dois jogadores.", icon_legend: "Legenda de Ícones",
                icon_streak_win: "3+ Vitórias Seguidas", icon_streak_loss: "3+ Derrotas Seguidas", icon_master: "Ninja Mestre (1000+ partidas)", icon_veteran: "Ninja Veterano (100+ partidas)",
                icon_elite: "Elite (WR >= 70%)", icon_nemesis: "Nêmesis (Quem mais te venceu)", icon_victim: "Vítima (Quem você mais venceu)", about_project: "Sobre o Projeto",
                about_text_1: "Este painel foi desenvolvido por Auriosh.", about_text_2: "É um projeto sem fins lucrativos e não remunerado, criado para a comunidade.", about_text_3: "A atualização dos dados é feita manualmente através das informações divulgadas no canal oficial Servidor do Discord.",
                share: "Compartilhar", won: "VENCEU", participated: "PARTICIPOU", no_tournament_period: "Nenhum torneio encontrado neste período.", stats_quick: "Estatísticas Rápidas",
                total_matches: "Total Partidas", win_rate_label: "Taxa de Vitória", nemesis: "Nêmesis", victim: "Vítima", history: "Histórico", matches: "Partidas", loading: "Carregando dados do Firebase...", error_loading: "Erro ao carregar dados", try_again: "Tentar Novamente",
                players_with: "Jogadores com:", listing: "Listando", players_found: "jogadores encontrados", players_of_village: "Jogadores da Vila:",
                upload_modal_title: "Enviar Arquivo JSON", upload_logs_btn: "Battle Logs (Partidas)", upload_players_btn: "Players Metadata (Vilas/Maestrias)", upload_success: "Envio concluído com sucesso!", upload_error: "Erro ao enviar:", uploading: "Enviando..."
            },
            en: {
                server: "Server: Hawk", to: "to",
                login_title: "Admin Area", login_text: "Login to manage data.", login_btn: "Login", logout: "Logout", upload_data: "Upload Data",
                search_placeholder: "Search player...", ranking: "Ranking", versus: "Versus", tournaments: "Tournaments", masteries: "Masteries", villages: "Villages",
                others: "Others", current_month: "This Month", day: "Last 24h", week: "Last Week", specific_month: "Select Month", all: "All Time", default_desc: "Detailed statistics for this specific game mode.",
                player1: "Player 1", player2: "Player 2", no_match: "No match found between these players.", winners: "Winners", losers: "Losers",
                victory_p1: "P1 VICTORY", defeat_p1: "P1 DEFEAT", see_tournament: "View Tournament", active_players: "Active Players", total_battles: "Total Battles", most_wins: "Most Wins", most_losses: "Most Losses",
                player: "Player", t_wins: "T. Won", t_played: "T. Played", wins: "Wins", losses: "Losses", battles: "Matches", win_rate: "Win Rate",
                no_player_found: "No player found for this filter.", date: "Date", tournament: "Tournament", time: "Time", no_tournament_found: "No tournament found for this filter.",
                manual_warning: "Attention: Manual Data", manual_warning_text: "Data in this section is manually updated consulting the Bingo Book. Outdated info may occur due to account resets or village changes. If you find errors, report on Discord. List will be updated over time.",
                ranking_masteries: "Mastery Ranking", ranking_masteries_sub: "Accumulated statistics by mastery.", combined: "Combined", individual: "Individual",
                mastery: "Mastery", total_wins: "Total Wins", no_mastery_data: "No mastery data found.", ranking_villages: "Village Ranking", ranking_villages_sub: "Accumulated statistics by village.",
                village: "Village", no_village_data: "No village data found.", files_loaded: "Data loaded from Firebase",
                // Modals
                how_to_use: "How to use", functionalities: "Features", features_list_1: "Ranking: See the best players on the server. Click a name to see match history and performance charts.",
                features_list_2: "Tournaments: Access past tournaments list. Click a tournament to view brackets and fight progress.", features_list_3: "Filters: Use mode (General, Ranked, etc.) and date filters to refine results.",
                features_list_4: "Versus: Compare direct performance between two players.", icon_legend: "Icon Legend",
                icon_streak_win: "3+ Win Streak", icon_streak_loss: "3+ Loss Streak", icon_master: "Master Ninja (1000+ matches)", icon_veteran: "Veteran Ninja (100+ matches)",
                icon_elite: "Elite (WR >= 70%)", icon_nemesis: "Nemesis (Who beat you most)", icon_victim: "Victim (Who you beat most)", about_project: "About Project",
                about_text_1: "This panel was developed by Auriosh.", about_text_2: "It is a non-profit, unpaid project created for the community.", about_text_3: "Data updates are done manually using information released on the official Discord Server channel.",
                share: "Share", won: "WON", participated: "PARTICIPATED", no_tournament_period: "No tournament found in this period.", stats_quick: "Quick Stats",
                total_matches: "Total Matches", win_rate_label: "Win Rate", nemesis: "Nemesis", victim: "Victim", history: "History", matches: "Matches", loading: "Loading data from Firebase...", error_loading: "Error loading data", try_again: "Try Again",
                players_with: "Players with:", listing: "Listing", players_found: "players found", players_of_village: "Players of Village:",
                upload_modal_title: "Upload JSON File", upload_logs_btn: "Battle Logs (Matches)", upload_players_btn: "Players Metadata (Villages/Masteries)", upload_success: "Upload successful!", upload_error: "Upload error:", uploading: "Uploading..."
            }
        };

        const MODE_DESCRIPTIONS = {
            'Geral': 'Overview of all matches registered on the server.',
            'Ranked': 'Sum of automated ranked queues (Auto1v1, Auto2v2, Auto3v3).',
            'Auto1v1': 'Automated ranked 1v1 matches.',
            'Auto2v2': 'Automated ranked 2v2 matches.',
            'Auto3v3': 'Automated ranked 3v3 matches.',
            'DBE1v1': 'Dodge Ball Event 1v1.',
            'DBE2v2': 'Dodge Ball Event 2v2.',
            'Default': 'Detailed statistics for this specific game mode.'
        };

        const Skeleton = ({ className }) => <div className={`animate-pulse bg-slate-800 rounded ${className}`}></div>;

        const SortIndicator = ({ active, direction }) => {
            if (!active) return <span className="ml-1 text-slate-700 opacity-20"><ChevronDown className="w-3 h-3 inline" /></span>; 
            return direction === 'asc' 
                ? <ChevronUp className="w-3 h-3 inline ml-1 text-yellow-500" />
                : <ChevronDown className="w-3 h-3 inline ml-1 text-yellow-500" />;
        };

        const ShareButton = ({ generateUrl, className, label }) => {
            const handleShare = () => {
                const url = generateUrl();
                const textArea = document.createElement("textarea");
                textArea.value = url;
                document.body.appendChild(textArea);
                textArea.select();
                try {
                    document.execCommand('copy');
                    alert("Link copied!");
                } catch (err) {
                    console.error('Error copying link', err);
                }
                document.body.removeChild(textArea);
            };

            return (
                <button 
                    onClick={handleShare} 
                    className={`flex items-center gap-2 px-3 py-1.5 rounded-full font-bold text-xs transition-colors ${className || 'bg-blue-600 hover:bg-blue-500 text-white'}`}
                    title="Copy link"
                >
                    <ShareIcon className="w-3.5 h-3.5" />
                    <span className="hidden sm:inline">{label}</span>
                </button>
            );
        };

        const LanguageSwitcher = ({ currentLang, setLang }) => (
            <div className="flex bg-slate-800 p-1 rounded-lg border border-slate-700 ml-2">
                <button onClick={() => setLang('pt')} className={`px-2 py-1 text-xs font-bold rounded transition-colors ${currentLang === 'pt' ? 'bg-green-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>PT</button>
                <button onClick={() => setLang('en')} className={`px-2 py-1 text-xs font-bold rounded transition-colors ${currentLang === 'en' ? 'bg-blue-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>EN</button>
            </div>
        );

        const UploadModal = ({ onClose, t }) => {
            useLockBodyScroll();
            const [status, setStatus] = useState('');
            const [isUploading, setIsUploading] = useState(false);
            const [progress, setProgress] = useState(0);

            const handleFileUpload = async (event, type) => {
                const file = event.target.files[0];
                if (!file) return;

                setIsUploading(true);
                setStatus(t.uploading);
                setProgress(0);

                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const json = JSON.parse(e.target.result);
                        if (!Array.isArray(json)) throw new Error("JSON must be an array");

                        const collectionName = type === 'logs' ? 'battle_logs' : 'players_metadata';
                        const BATCH_SIZE = 400; // Firestore limit is 500
                        const total = json.length;
                        let processed = 0;

                        // Chunk array
                        for (let i = 0; i < total; i += BATCH_SIZE) {
                            const chunk = json.slice(i, i + BATCH_SIZE);
                            const batch = writeBatch(db);

                            chunk.forEach(item => {
                                const docRef = doc(collection(db, collectionName));
                                batch.set(docRef, item);
                            });

                            await batch.commit();
                            processed += chunk.length;
                            setProgress(Math.round((processed / total) * 100));
                        }
                        
                        setStatus(t.upload_success);
                        setTimeout(() => { onClose(); window.location.reload(); }, 2000);
                    } catch (error) {
                        console.error(error);
                        setStatus(`${t.upload_error} ${error.message}`);
                    } finally {
                        setIsUploading(false);
                    }
                };
                reader.readAsText(file);
            };

            return (
                 <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex justify-center items-center p-4 z-[90]" onClick={onClose}>
                    <div className="bg-slate-900 w-full max-w-lg rounded-2xl shadow-2xl border border-slate-700 p-6" onClick={(e) => e.stopPropagation()}>
                        <div className="flex justify-between items-center mb-6">
                            <h2 className="text-xl font-bold text-white flex items-center gap-2"><UploadCloud className="w-6 h-6 text-blue-400"/> {t.upload_modal_title}</h2>
                            <button onClick={onClose} className="p-2 hover:bg-slate-700 rounded-full text-slate-400"><XIcon className="w-5 h-5" /></button>
                        </div>
                        
                        {!isUploading ? (
                            <div className="space-y-4">
                                <div className="p-4 border border-dashed border-slate-600 rounded-lg hover:border-yellow-500 transition-colors text-center">
                                    <label className="cursor-pointer block">
                                        <div className="text-yellow-500 font-bold mb-1">{t.upload_logs_btn}</div>
                                        <div className="text-xs text-slate-500">JSON Array of matches</div>
                                        <input type="file" className="hidden" accept=".json" onChange={(e) => handleFileUpload(e, 'logs')} />
                                    </label>
                                </div>
                                <div className="p-4 border border-dashed border-slate-600 rounded-lg hover:border-blue-500 transition-colors text-center">
                                    <label className="cursor-pointer block">
                                        <div className="text-blue-400 font-bold mb-1">{t.upload_players_btn}</div>
                                        <div className="text-xs text-slate-500">JSON Array of player details</div>
                                        <input type="file" className="hidden" accept=".json" onChange={(e) => handleFileUpload(e, 'players')} />
                                    </label>
                                </div>
                            </div>
                        ) : (
                            <div className="text-center py-8">
                                <Loader2 className="w-10 h-10 text-blue-500 animate-spin mx-auto mb-4" />
                                <div className="text-white font-bold mb-2">{status}</div>
                                <div className="w-full bg-slate-800 rounded-full h-2.5">
                                    <div className="bg-blue-600 h-2.5 rounded-full transition-all duration-300" style={{ width: `${progress}%` }}></div>
                                </div>
                                <div className="text-xs text-slate-400 mt-2">{progress}%</div>
                            </div>
                        )}
                        {status && !isUploading && <div className={`mt-4 text-center font-bold ${status.includes('Erro') ? 'text-red-400' : 'text-green-400'}`}>{status}</div>}
                    </div>
                 </div>
            );
        };

        // --- APP LOGIC ---

        const processBattleLogs = (data) => {
            const stats = {};
            const history = {};
            const rivalry = {}; 
            const initPlayer = (name) => {
                if (!stats[name]) {
                    stats[name] = { name, wins: 0, losses: 0, battles: 0, winRate: 0, modes: {}, streak: 0, maxStreak: 0, badges: [] };
                    history[name] = [];
                    rivalry[name] = {};
                }
            };
            const updateModeStats = (playerName, mode, result) => {
                if (!stats[playerName].modes[mode]) { stats[playerName].modes[mode] = { wins: 0, losses: 0, battles: 0 }; }
                stats[playerName].modes[mode].battles += 1;
                if (result === 'win') stats[playerName].modes[mode].wins += 1; else stats[playerName].modes[mode].losses += 1;
            };
            const updateRivalry = (player, opponent, result) => {
                if (!rivalry[player][opponent]) rivalry[player][opponent] = { wins: 0, losses: 0 };
                if (result === 'win') rivalry[player][opponent].wins += 1; else rivalry[player][opponent].losses += 1;
            }
            if (!Array.isArray(data)) return { rankings: [], history: {} };
            const sortedData = [...data].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
            sortedData.forEach(log => {
                const content = log.content || "";
                const match = content.match(/^\[(.*?)\] (.*?) derrotou (.*)/);
                if (match) {
                    const mode = match[1]; 
                    const winners = match[2].split(',').map(n => n.trim()).filter(n => n.length > 0);
                    const losers = match[3].split(',').map(n => n.trim()).filter(n => n.length > 0);
                    const timestamp = log.timestamp;
                    winners.forEach(winner => {
                        initPlayer(winner); stats[winner].wins += 1; stats[winner].battles += 1; updateModeStats(winner, mode, 'win');
                        history[winner].push({ opponent: losers.join(', '), result: 'win', timestamp: timestamp, mode: mode });
                        if (stats[winner].streak >= 0) stats[winner].streak += 1; else stats[winner].streak = 1;
                        losers.forEach(loser => updateRivalry(winner, loser, 'win'));
                    });
                    losers.forEach(loser => {
                        initPlayer(loser); stats[loser].losses += 1; stats[loser].battles += 1; updateModeStats(loser, mode, 'loss');
                        history[loser].push({ opponent: winners.join(', '), result: 'loss', timestamp: timestamp, mode: mode });
                        if (stats[loser].streak <= 0) stats[loser].streak -= 1; else stats[loser].streak = -1;
                        winners.forEach(winner => updateRivalry(loser, winner, 'loss'));
                    });
                }
            });
            const rankings = Object.values(stats).map(player => {
                let nemesis = { name: null, count: 0 }, victim = { name: null, count: 0 };
                if (rivalry[player.name]) {
                    Object.entries(rivalry[player.name]).forEach(([opp, s]) => {
                        if (s.losses > nemesis.count) nemesis = { name: opp, count: s.losses };
                        if (s.wins > victim.count) victim = { name: opp, count: s.wins };
                    });
                }
                const badges = [];
                const wr = player.battles > 0 ? (player.wins / player.battles) * 100 : 0;
                if (player.battles >= 20 && wr >= 70) badges.push({ id: 'elite', icon: Star, label: 'Elite', color: 'text-yellow-400' });
                return { ...player, winRate: wr.toFixed(1), nemesis: nemesis.count > 0 ? nemesis : null, victim: victim.count > 0 ? victim : null, badges };
            }).sort((a, b) => b.wins - a.wins);
            return { rankings, history };
        };

        const Card = ({ title, value, icon: Icon, colorClass }) => (
            <div className="bg-slate-800 p-6 rounded-lg shadow-lg border border-slate-700 flex items-center space-x-4 animate-in fade-in duration-500">
                <div className={`p-3 rounded-full ${colorClass} bg-opacity-20`}><Icon className={`w-6 h-6 ${colorClass.replace('bg-', 'text-')}`} /></div>
                <div><p className="text-slate-400 text-sm font-medium">{title}</p><h3 className="text-2xl font-bold text-white">{value}</h3></div>
            </div>
        );

        const PlayerPerformanceChart = ({ matches, t }) => {
            const [hoveredStat, setHoveredStat] = useState(null);
            const [tooltipPos, setTooltipPos] = useState({ x: 0, y: 0 });
            const scrollRef = useRef(null);
            const statsByDate = useMemo(() => {
                const groups = {};
                const sortedMatches = [...matches].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                sortedMatches.forEach(match => {
                    const date = new Date(match.timestamp).toLocaleDateString('pt-BR', { day: '2-digit', month: '2-digit' });
                    if (!groups[date]) groups[date] = { date, wins: 0, losses: 0, total: 0 };
                    groups[date].total += 1;
                    if (match.result === 'win') groups[date].wins += 1; else groups[date].losses += 1;
                });
                return Object.values(groups); 
            }, [matches]);
            useLayoutEffect(() => { if (scrollRef.current) setTimeout(() => { if (scrollRef.current) scrollRef.current.scrollLeft = scrollRef.current.scrollWidth; }, 50); }, [statsByDate]);
            const handleMouseMove = (e) => { setTooltipPos({ x: e.clientX, y: e.clientY }); };
            if (statsByDate.length === 0) return null;
            const maxVal = Math.max(...statsByDate.map(d => Math.max(d.wins, d.losses))); 
            return (
                <div className="bg-slate-950/50 rounded-xl p-4 border border-slate-800 mb-4 flex flex-col relative" >
                    {hoveredStat && (<div className="fixed z-50 pointer-events-none bg-slate-800 border border-slate-600 text-slate-100 text-xs rounded px-3 py-2 shadow-xl flex flex-col gap-1 min-w-[100px]" style={{ left: tooltipPos.x + 15, top: tooltipPos.y - 15 }}><span className="font-bold border-b border-slate-700 pb-1 mb-1">{hoveredStat.date}</span><div className="flex justify-between"><span className="text-green-400 font-bold">{t.wins}:</span><span>{hoveredStat.wins}</span></div><div className="flex justify-between"><span className="text-red-400 font-bold">{t.losses}:</span><span>{hoveredStat.losses}</span></div></div>)}
                    <div className="flex justify-between items-start mb-4"><h4 className="text-slate-400 text-xs font-bold uppercase flex items-center gap-2"><TrendingUp className="w-4 h-4 text-yellow-500"/> Desempenho (Dia)</h4></div>
                    <div ref={scrollRef} className="overflow-x-auto pb-2 scrollbar-thin scrollbar-thumb-slate-700 scrollbar-track-slate-800/50" onMouseMove={handleMouseMove}><div className="flex items-end gap-3 h-32 px-2 min-w-max">{statsByDate.map((stat, idx) => { const winHeight = stat.wins > 0 ? Math.max((stat.wins / maxVal) * 100, 5) : 0; const lossHeight = stat.losses > 0 ? Math.max((stat.losses / maxVal) * 100, 5) : 0; return (<div key={idx} className="flex flex-col items-center justify-end h-full w-12 min-w-[48px] group relative flex-shrink-0 cursor-default hover:bg-white/5 rounded transition-colors" onMouseEnter={() => setHoveredStat(stat)} onMouseLeave={() => setHoveredStat(null)}><div className="w-full flex items-end justify-center gap-1 h-full px-1"><div className="flex-1 bg-slate-800/30 rounded-t-sm h-full flex items-end relative overflow-hidden"><div style={{ height: `${winHeight}%` }} className={`w-full transition-all duration-300 ${hoveredStat === stat ? 'bg-green-400' : 'bg-green-600'}`}></div></div><div className="flex-1 bg-slate-800/30 rounded-t-sm h-full flex items-end relative overflow-hidden"><div style={{ height: `${lossHeight}%` }} className={`w-full transition-all duration-300 ${hoveredStat === stat ? 'bg-red-400' : 'bg-red-600'}`}></div></div></div><span className={`text-[10px] mt-2 font-mono whitespace-nowrap transition-colors ${hoveredStat === stat ? 'text-white font-bold' : 'text-slate-500'}`}>{stat.date}</span></div>) })}</div></div>
                </div>
            );
        };

        const TournamentBracketModal = ({ tournament, onClose, onPlayerClick, getShareLink, t }) => {
            useLockBodyScroll(); 
            if (!tournament) return null;
            const matches = [...tournament.matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const rounds = { 'Final': [matches[0]].filter(Boolean), 'Semifinais': matches.slice(1, 3), 'Quartas de Final': matches.slice(3, 7), 'Classificatórias': matches.slice(7) };
            return (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex justify-center items-center p-4 z-[70]" onClick={onClose}>
                    <div className="bg-slate-900 w-full max-w-5xl rounded-2xl shadow-2xl border border-slate-700 overflow-hidden flex flex-col h-[90vh]" onClick={(e) => e.stopPropagation()}>
                        <div className="p-6 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                            <div><h2 className="text-2xl font-bold text-white flex items-center gap-3"><Trophy className="text-yellow-500 w-6 h-6" />{tournament.name}</h2><p className="text-slate-400 text-sm mt-1">{tournament.date}</p></div>
                            <div className="flex gap-2"><ShareButton generateUrl={() => getShareLink(tournament)} className="bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-700" label={t.share} /><button onClick={onClose} className="p-2 hover:bg-slate-700 rounded-full transition-colors text-slate-400 hover:text-white"><XIcon className="w-6 h-6" /></button></div>
                        </div>
                        <div className="flex-1 overflow-y-auto p-6 scrollbar-thin bg-slate-950/50">
                            {Object.entries(rounds).map(([roundName, roundMatches]) => {
                                if (roundMatches.length === 0) return null;
                                return (
                                    <div key={roundName} className="mb-8 last:mb-0"><div className="flex items-center gap-4 mb-4"><div className="h-px bg-slate-700 flex-1"></div><h3 className="text-yellow-500 font-bold uppercase tracking-widest text-sm">{roundName}</h3><div className="h-px bg-slate-700 flex-1"></div></div><div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-2 gap-4">{roundMatches.map((match, idx) => (<div key={idx} className="bg-slate-900 border border-slate-800 rounded-lg p-4 flex flex-col items-center justify-center relative overflow-hidden group hover:border-slate-600 transition-colors"><div className="w-full flex justify-between items-center mb-2"><div className="flex flex-wrap gap-1 flex-1">{match.winners.map((name, i) => (<span key={i} onClick={(e) => { e.stopPropagation(); onPlayerClick(name); }} className="text-green-400 font-bold hover:text-white hover:underline cursor-pointer transition-colors">{name}{i < match.winners.length - 1 ? ',' : ''}</span>))}</div><Trophy className="w-4 h-4 text-yellow-500 ml-2 flex-shrink-0" /></div><div className="w-full h-px bg-slate-800 my-1"></div><div className="w-full flex justify-between items-center mt-2 opacity-60"><div className="flex flex-wrap gap-1 flex-1">{match.losers.map((name, i) => (<span key={i} onClick={(e) => { e.stopPropagation(); onPlayerClick(name); }} className="text-red-400 font-medium hover:text-white hover:underline cursor-pointer transition-colors">{name}{i < match.losers.length - 1 ? ',' : ''}</span>))}</div></div><div className="absolute top-2 right-2 text-[10px] text-slate-600 bg-slate-900 px-1 rounded">{new Date(match.timestamp).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'})}</div></div>))}</div></div>
                                );
                            })}
                        </div>
                    </div>
                </div>
            );
        };

        const MasteryDetailsModal = ({mastery, players, onClose, onPlayerClick, t }) => {
            useLockBodyScroll(); 
            return (
                <div className="fixed inset-0 bg-black/90 backdrop-blur-sm flex justify-center items-center p-4 z-50 animate-in fade-in duration-200" onClick={onClose}>
                    <div className="bg-slate-900 w-full max-w-4xl rounded-2xl shadow-2xl border border-slate-700 overflow-hidden flex flex-col max-h-[90vh]" onClick={(e) => e.stopPropagation()}>
                        <div className="p-6 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                            <div><h2 className="text-2xl font-bold text-white flex items-center gap-3"><BookOpen className="text-blue-400 w-6 h-6" />{t.players_with} {mastery}</h2><p className="text-slate-400 text-sm mt-1">{t.listing} {players.length} {t.players_found}</p></div>
                            <button onClick={onClose} className="p-2 hover:bg-slate-700 rounded-full transition-colors text-slate-400 hover:text-white"><XIcon className="w-6 h-6" /></button>
                        </div>
                        <div className="flex-1 overflow-y-auto p-0 scrollbar-thin bg-slate-950/50">
                             <table className="w-full text-left border-collapse">
                                <thead className="sticky top-0 bg-slate-900 z-10 shadow-md">
                                    <tr className="border-b border-slate-800 text-slate-400 text-xs font-bold uppercase tracking-wider"><th className="p-5">#</th><th className="p-5">{t.player}</th><th className="p-5 text-center">{t.wins}</th><th className="p-5 text-center">{t.losses}</th><th className="p-5 text-center">{t.battles}</th><th className="p-5 text-center">{t.win_rate}</th></tr>
                                </thead>
                                <tbody className="divide-y divide-slate-800">
                                    {players.map((player, index) => {
                                        let rankColor = "text-slate-500", rankIcon = null;
                                        if (index === 0) { rankColor = "text-yellow-500"; rankIcon = <Trophy className="w-4 h-4 mx-auto" />; }
                                        if (index === 1) { rankColor = "text-slate-300"; rankIcon = <Medal className="w-4 h-4 mx-auto" />; }
                                        if (index === 2) { rankColor = "text-amber-700"; rankIcon = <Medal className="w-4 h-4 mx-auto" />; }
                                        return (
                                            <tr key={player.name} onClick={() => onPlayerClick(player)} className="hover:bg-slate-800/50 cursor-pointer transition-colors group">
                                                <td className={`p-5 text-center font-bold ${rankColor} text-lg w-16`}>{rankIcon || `#${index + 1}`}</td><td className="p-5"><span className="font-semibold text-white group-hover:text-yellow-400 transition-colors text-lg">{player.name}</span></td><td className="p-5 text-center font-bold text-yellow-500">{player.wins}</td><td className="p-5 text-center font-medium text-red-500">{player.losses}</td><td className="p-5 text-center text-blue-400 font-bold">{player.battles}</td><td className="p-5 text-center"><span className={`text-xs font-bold px-2 py-1 rounded-full ${parseFloat(player.winRate) >= 60 ? 'bg-green-500/20 text-green-400' : parseFloat(player.winRate) >= 40 ? 'bg-yellow-500/20 text-yellow-400' : 'bg-red-500/20 text-red-400'}`}>{player.winRate}%</span></td>
                                            </tr>
                                        );
                                    })}
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
            );
        };

        const InfoModal = ({ onClose, t }) => {
            useLockBodyScroll(); 
            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex justify-center items-center p-4 z-50 animate-in fade-in duration-200" onClick={onClose}>
                    <div className="bg-slate-900 w-full max-w-lg rounded-2xl shadow-2xl border border-slate-700 overflow-hidden flex flex-col" onClick={(e) => e.stopPropagation()}>
                        <div className="p-6 border-b border-slate-700 flex justify-between items-center bg-slate-800/50">
                            <h2 className="text-xl font-bold text-white flex items-center gap-2"><HelpCircle className="w-5 h-5 text-blue-400" />{t.how_to_use}</h2>
                            <button onClick={onClose} className="p-1.5 hover:bg-slate-700 rounded-full transition-colors text-slate-400 hover:text-white"><XIcon className="w-5 h-5" /></button>
                        </div>
                        <div className="p-6 text-slate-300 text-sm leading-relaxed space-y-4 max-h-[80vh] overflow-y-auto scrollbar-thin">
                            <div className="space-y-2">
                                <h3 className="text-yellow-500 font-bold uppercase text-xs tracking-wider">{t.functionalities}</h3>
                                <ul className="list-disc pl-5 space-y-1 marker:text-slate-600">
                                    <li>{t.features_list_1}</li><li>{t.features_list_2}</li><li>{t.features_list_3}</li><li>{t.features_list_4}</li>
                                </ul>
                            </div>
                            <div className="h-px bg-slate-800 w-full"></div>
                            <div className="space-y-2">
                                <h3 className="text-yellow-500 font-bold uppercase text-xs tracking-wider">{t.icon_legend}</h3>
                                <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 text-xs">
                                    <div className="flex items-center gap-2"><Flame className="w-4 h-4 text-orange-500" /> <span>{t.icon_streak_win}</span></div>
                                    <div className="flex items-center gap-2"><Skull className="w-4 h-4 text-slate-500" /> <span>{t.icon_streak_loss}</span></div>
                                    <div className="flex items-center gap-2"><ShurikenIcon className="w-4 h-4 text-yellow-400 drop-shadow-[0_0_2px_rgba(250,204,21,0.8)]" /> <span>{t.icon_master}</span></div>
                                    <div className="flex items-center gap-2"><ShurikenIcon className="w-4 h-4 text-blue-400" /> <span>{t.icon_veteran}</span></div>
                                    <div className="flex items-center gap-2"><Star className="w-4 h-4 text-yellow-400" /> <span>{t.icon_elite}</span></div>
                                    <div className="flex items-center gap-2"><Skull className="w-4 h-4 text-red-500" /> <span>{t.icon_nemesis}</span></div>
                                    <div className="flex items-center gap-2"><Swords className="w-4 h-4 text-green-500" /> <span>{t.icon_victim}</span></div>
                                </div>
                            </div>
                            <div className="h-px bg-slate-800 w-full"></div>
                            <div className="space-y-2">
                                <h3 className="text-yellow-500 font-bold uppercase text-xs tracking-wider">{t.about_project}</h3>
                                <p>{t.about_text_1}</p><p className="text-xs text-slate-500">{t.about_text_2}</p><p className="text-xs text-slate-500">{t.about_text_3}</p>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const PlayerModal = ({ player, history, tournaments, activeTab, onClose, onNavigateToPlayer, onOpenTournament, getShareLink, t }) => {
            useLockBodyScroll(); 
            const [historyView, setHistoryView] = useState('matches'); 
            if (!player) return null;
            const allMatches = history[player.name] || [];
            const playerMatches = useMemo(() => {
                if (activeTab === 'Geral') return allMatches;
                if (activeTab === 'Ranked') { return allMatches.filter(match => ['Auto1v1', 'Auto2v2', 'Auto3v3'].includes(match.mode)); }
                return allMatches.filter(match => match.mode === activeTab);
            }, [allMatches, activeTab]);
            const sortedMatches = [...playerMatches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            const { localNemesis, localVictim } = useMemo(() => {
                const rivalryStats = {};
                playerMatches.forEach(match => {
                    const opponents = match.opponent.split(',').map(n => n.trim()).filter(n => n.length > 0);
                    opponents.forEach(opp => { if (!rivalryStats[opp]) rivalryStats[opp] = { wins: 0, losses: 0 }; if (match.result === 'win') rivalryStats[opp].wins++; else rivalryStats[opp].losses++; });
                });
                let bestVictim = { name: null, count: 0 }, worstNemesis = { name: null, count: 0 };
                Object.entries(rivalryStats).forEach(([name, stats]) => { if (stats.wins > bestVictim.count) bestVictim = { name, count: stats.wins }; if (stats.losses > worstNemesis.count) worstNemesis = { name, count: stats.losses }; });
                return { localNemesis: worstNemesis.count > 0 ? worstNemesis : null, localVictim: bestVictim.count > 0 ? bestVictim : null };
            }, [playerMatches]);
            const matchesByDate = sortedMatches.reduce((groups, match) => {
                const date = match.timestamp ? new Date(match.timestamp).toLocaleDateString('pt-BR') : 'Data desconhecida';
                if (!groups[date]) groups[date] = []; groups[date].push(match); return groups;
            }, {});
            const playerTournaments = useMemo(() => {
                if (!tournaments) return [];
                return tournaments.filter(t => t.matches.some(m => m.winners.includes(player.name) || m.losers.includes(player.name))).map(t => {
                    const sortedMatches = [...t.matches].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                    const lastMatch = sortedMatches[sortedMatches.length - 1];
                    const isWinner = lastMatch && lastMatch.winners.includes(player.name);
                    return { ...t, isWinner };
                });
            }, [tournaments, player.name]);

            return (
                <div className="fixed inset-0 bg-black/80 backdrop-blur-sm flex justify-center items-center p-4 z-[80]" onClick={onClose}>
                    <div className="bg-slate-900 w-full max-w-6xl rounded-2xl shadow-2xl border border-slate-700 overflow-hidden flex flex-col h-[90vh]" onClick={(e) => e.stopPropagation()}>
                        <div className="p-6 border-b border-slate-700 flex justify-between items-start bg-slate-800/50 flex-shrink-0">
                            <div className="flex flex-col gap-2">
                                <h2 className="text-3xl font-bold text-white mb-0 flex items-center gap-2">{player.name}{parseFloat(player.winRate) >= 60 && <TrendingUp className="w-6 h-6 text-green-400" />}</h2>
                                <div className="flex flex-wrap gap-4 text-sm text-slate-400 items-center mt-1">
                                    <span className="bg-slate-800 px-2 py-0.5 rounded border border-slate-700 text-xs text-yellow-500 font-bold uppercase tracking-wider">{activeTab}</span>
                                    <span>{player.wins} {t.wins}</span><span>{player.losses} {t.losses}</span><span className={parseFloat(player.winRate) >= 50 ? 'text-green-400' : 'text-red-400'}>{player.winRate}% WR</span><span className="text-yellow-500 font-bold">{player.tournamentWins || 0} {t.t_wins}</span>
                                    {player.meta && (player.meta.village || player.meta.mastery_1) && (<div className="flex items-center gap-2 px-2 border-l border-r border-slate-700">{player.meta.village && (<span className={`text-[10px] font-bold px-1.5 py-0.5 rounded border border-slate-700 bg-slate-800/50 uppercase tracking-wide ${STYLE_MAP[player.meta.village] || 'text-slate-400'}`}>{player.meta.village}</span>)}{player.meta.mastery_1 && (<span className={`text-[10px] font-bold px-1.5 py-0.5 rounded border uppercase tracking-wide ${STYLE_MAP[player.meta.mastery_1] || 'bg-slate-800 text-slate-400 border-slate-700'}`}>{player.meta.mastery_1}</span>)}{player.meta.mastery_2 && (<span className={`text-[10px] font-bold px-1.5 py-0.5 rounded border uppercase tracking-wide ${STYLE_MAP[player.meta.mastery_2] || 'bg-slate-800 text-slate-400 border-slate-700'}`}>{player.meta.mastery_2}</span>)}</div>)}
                                    {player.badges && player.badges.length > 0 && (<div className="flex items-center gap-2 pl-2">{player.badges.map((badge, idx) => { const BadgeIcon = badge.icon; return (<div key={idx} className="flex items-center gap-1.5 px-2 py-0.5 rounded bg-slate-900 border border-slate-700 shadow-sm" title={badge.label}><BadgeIcon className={`w-3.5 h-3.5 ${badge.color}`} /><span className="text-[10px] font-bold text-slate-300 uppercase tracking-wide hidden sm:inline-block">{badge.label}</span></div>); })}</div>)}
                                    {(player.streak || 0) >= 3 && (<div className="flex items-center gap-1.5 px-2 py-0.5 rounded bg-orange-900/30 border border-orange-500/30 shadow-sm ml-2"><Flame className="w-3.5 h-3.5 text-orange-500" /><span className="text-[10px] font-bold text-orange-300 uppercase tracking-wide hidden sm:inline-block">{t.icon_streak_win}</span></div>)}
                                    {(player.streak || 0) <= -3 && (<div className="flex items-center gap-1.5 px-2 py-0.5 rounded bg-red-900/30 border border-red-500/30 shadow-sm ml-2"><Skull className="w-3.5 h-3.5 text-red-500" /><span className="text-[10px] font-bold text-red-300 uppercase tracking-wide hidden sm:inline-block">{t.icon_streak_loss}</span></div>)}
                                </div>
                            </div>
                            <div className="flex gap-2"><ShareButton generateUrl={() => getShareLink(player)} className="bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-700" label={t.share} /><button onClick={onClose} className="text-slate-400 hover:text-white transition-colors p-2 hover:bg-slate-700 rounded-full"><XIcon className="w-6 h-6" /></button></div>
                        </div>
                        <div className="flex-1 overflow-hidden min-h-0">
                            <div className="h-full flex flex-col lg:flex-row-reverse">
                                <div className="w-full lg:w-[45%] p-4 lg:p-6 bg-slate-900 lg:border-l border-b lg:border-b-0 border-slate-800 overflow-y-auto lg:overflow-visible flex-shrink-0">
                                    <PlayerPerformanceChart matches={playerMatches} t={t} />
                                    <div className="bg-slate-950/30 p-4 rounded-xl border border-slate-800 w-full">
                                        <h4 className="text-slate-400 text-xs font-bold uppercase mb-3 flex items-center gap-2"><InfoIcon className="w-4 h-4 text-blue-500"/> {t.stats_quick}</h4>
                                        <div className="space-y-3 text-sm">
                                            <div className="flex justify-between text-slate-300"><span>{t.total_matches}</span><span className="font-bold">{playerMatches.length}</span></div><div className="flex justify-between text-slate-300"><span>{t.win_rate_label}</span><span className={parseFloat(player.winRate) >= 50 ? 'text-green-400 font-bold' : 'text-red-400 font-bold'}>{player.winRate}%</span></div><div className="h-px bg-slate-800 my-1"></div>
                                            {localNemesis && (<div className="flex justify-between items-center gap-4"><span className="text-slate-400 flex items-center gap-1.5 flex-shrink-0"><Skull className="w-3.5 h-3.5 text-red-500"/> {t.nemesis}</span><div className="text-right overflow-hidden"><span className="text-red-400 font-bold block leading-tight truncate hover:underline cursor-pointer" onClick={() => onNavigateToPlayer(localNemesis.name)}>{localNemesis.name}</span><span className="text-[10px] text-slate-600 whitespace-nowrap">{localNemesis.count} {t.losses}</span></div></div>)}
                                            {localVictim && (<div className="flex justify-between items-center gap-4"><span className="text-slate-400 flex items-center gap-1.5 flex-shrink-0"><Swords className="w-3.5 h-3.5 text-green-500"/> {t.victim}</span><div className="text-right overflow-hidden"><span className="text-green-400 font-bold block leading-tight truncate hover:underline cursor-pointer" onClick={() => onNavigateToPlayer(localVictim.name)}>{localVictim.name}</span><span className="text-[10px] text-slate-600 whitespace-nowrap">{localVictim.count} {t.wins}</span></div></div>)}
                                        </div>
                                    </div>
                                </div>
                                <div className="w-full lg:w-[55%] flex flex-col h-full bg-slate-950/20">
                                    <div className="p-4 lg:p-6 pb-2 border-b border-slate-800 bg-slate-900/50 backdrop-blur-sm z-20 flex-shrink-0 flex justify-between items-center"><h3 className="text-lg font-bold text-white flex items-center gap-2"><Clock className="w-5 h-5 text-slate-500"/> {t.history}</h3><div className="flex bg-slate-800 p-1 rounded-lg border border-slate-700"><button onClick={() => setHistoryView('matches')} className={`px-3 py-1 text-xs font-bold rounded transition-colors ${historyView === 'matches' ? 'bg-blue-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>{t.matches}</button><button onClick={() => setHistoryView('tournaments')} className={`px-3 py-1 text-xs font-bold rounded transition-colors ${historyView === 'tournaments' ? 'bg-blue-600 text-white shadow' : 'text-slate-400 hover:text-white'}`}>{t.tournaments}</button></div></div>
                                    <div className="flex-1 overflow-y-auto p-4 lg:p-6 pt-0 scrollbar-thin relative">
                                        {historyView === 'matches' ? (
                                            Object.keys(matchesByDate).length > 0 ? (
                                                Object.entries(matchesByDate).map(([date, matches]) => (<div key={date} className="mb-6 last:mb-0"><div className="bg-slate-900 border-b border-slate-800 py-2 mb-3 shadow-md"><div className="flex items-center gap-2"><Calendar className="w-4 h-4 text-yellow-500" /><h4 className="text-slate-300 text-sm font-bold uppercase tracking-wider">{date}</h4><span className="text-xs text-slate-600 font-medium bg-slate-800 px-2 rounded-full border border-slate-700">{matches.length} {t.matches}</span></div></div><div className="space-y-2">{matches.map((match, idx) => (<div key={idx} className={`p-3 rounded-lg border flex flex-col sm:flex-row justify-between items-start sm:items-center gap-2 transition-all ${match.result === 'win' ? 'bg-green-900/5 border-green-500/10 hover:bg-green-900/10' : 'bg-red-900/5 border-red-500/10 hover:bg-red-900/10'}`}><div className="flex flex-col"><span className="text-[10px] font-bold uppercase tracking-wider text-slate-500 mb-0.5 flex items-center gap-1">{match.mode}</span><div className="flex items-center gap-2 text-slate-200 text-sm font-medium flex-wrap"><span className={match.result === 'win' ? 'text-green-500 font-bold' : 'text-red-500 font-bold'}>{match.result === 'win' ? 'V' : 'D'}</span><span className="text-slate-600">vs</span>{match.opponent.split(',').map((oppName, i, arr) => (<React.Fragment key={i}><span className="hover:text-yellow-400 hover:underline cursor-pointer transition-colors" onClick={(e) => { e.stopPropagation(); onNavigateToPlayer(oppName.trim()); }}>{oppName.trim()}</span>{i < arr.length - 1 && <span className="text-slate-600 mr-1">,</span>}</React.Fragment>))}</div></div><div className="text-right flex items-center gap-2 text-slate-500 text-xs"><span>{match.timestamp ? new Date(match.timestamp).toLocaleTimeString('pt-BR', {day: '2-digit', month: '2-digit', hour: '2-digit', minute: '2-digit'}).replace(',', '') : '--:--'}</span></div></div>))}</div></div>))
                                            ) : (<div className="text-center py-10 text-slate-500">{t.no_matches}</div>)
                                        ) : (
                                            <div className="space-y-3 mt-4">
                                                {playerTournaments.length > 0 ? playerTournaments.map(tData => (<div key={tData.id} onClick={() => onOpenTournament(tData)} className={`p-3 rounded-lg border flex justify-between items-center cursor-pointer transition-all hover:shadow-md group ${tData.isWinner ? 'bg-yellow-900/10 border-yellow-500/30 hover:border-yellow-500/50' : 'bg-slate-900 border-slate-800 hover:border-slate-600'}`}><div className="flex flex-col"><span className="text-[10px] font-bold uppercase tracking-wider text-slate-500 mb-0.5">{tData.date}</span><div className="font-bold text-white group-hover:text-yellow-400 transition-colors flex items-center gap-2">{tData.name}{tData.isWinner && <Trophy className="w-3 h-3 text-yellow-500" />}</div></div><div className="flex items-center gap-3"><span className={`text-xs font-bold px-2 py-1 rounded border ${tData.isWinner ? 'text-yellow-500 bg-yellow-500/10 border-yellow-500/20' : 'text-slate-400 bg-slate-800 border-slate-700'}`}>{tData.isWinner ? t.won : t.participated}</span><ChevronRight className="w-4 h-4 text-slate-600 group-hover:text-white" /></div></div>)) : (<div className="text-center py-10 text-slate-500">{t.no_tournament_period}</div>)}
                                            </div>
                                        )}
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            );
        };

        const App = () => {
            const [rawData, setRawData] = useState([]);
            const [playersMetadata, setPlayersMetadata] = useState({});
            const [data, setData] = useState({ rankings: [], history: {} });
            const [isLoading, setIsLoading] = useState(true);
            const [error, setError] = useState(null);
            const [user, setUser] = useState(null);
            const [showUploadModal, setShowUploadModal] = useState(false);
            
            // --- LANGUAGE STATE ---
            const [language, setLanguage] = useState(() => {
                const browserLang = navigator.language || navigator.userLanguage;
                return (browserLang === 'pt-BR' || browserLang === 'pt') ? 'pt' : 'en';
            });
            const t = TRANSLATIONS[language];

            const [searchTerm, setSearchTerm] = useState('');
            const [sortConfig, setSortConfig] = useState({ key: 'tournamentWins', direction: 'desc' });
            const [activeTab, setActiveTab] = useState('Geral');
            const [selectedPlayer, setSelectedPlayer] = useState(null);
            
            const [currentPage, setCurrentPage] = useState(1);
            const ITEMS_PER_PAGE = 50;

            const [timeFilter, setTimeFilter] = useState('current_month');
            const [availableMonths, setAvailableMonths] = useState([]);
            const [targetMonth, setTargetMonth] = useState('');
            const [dateRange, setDateRange] = useState({ start: null, end: null });
            
            const [showOtherModes, setShowOtherModes] = useState(false);
            const [viewMode, setViewMode] = useState('ranking'); 
            const [selectedTournament, setSelectedTournament] = useState(null);
            const [showInfoModal, setShowInfoModal] = useState(false);
            
            const [masteryViewMode, setMasteryViewMode] = useState('combined');
            const [selectedMastery, setSelectedMastery] = useState(null);
            const [selectedVillage, setSelectedVillage] = useState(null);

            const [versusPlayer1, setVersusPlayer1] = useState('');
            const [versusPlayer2, setVersusPlayer2] = useState('');
            
            const [loadedFilesCount, setLoadedFilesCount] = useState(0);

            // Auth State Listener
            useEffect(() => {
                const unsubscribe = onAuthStateChanged(auth, (currentUser) => {
                    setUser(currentUser);
                });
                return () => unsubscribe();
            }, []);

            const handleLogin = async (e) => {
                e.preventDefault();
                const email = e.target.email.value;
                const password = e.target.password.value;
                try {
                    await signInWithEmailAndPassword(auth, email, password);
                } catch (error) {
                    console.error("Login Error:", error);
                    alert("Erro ao fazer login: " + error.message);
                }
            };

            const handleLogout = async () => {
                try {
                    await signOut(auth);
                } catch (error) {
                    console.error("Logout Error:", error);
                }
            };

            // Helper to calculate ranking month based on custom rule (Day 2 to Day 1 of next month)
            const getRankingMonth = (dateObj) => {
                const day = dateObj.getDate();
                let month = dateObj.getMonth();
                let year = dateObj.getFullYear();
                
                // If day is 1, it belongs to the previous month
                if (day === 1) {
                    month--;
                    if (month < 0) {
                        month = 11;
                        year--;
                    }
                }
                return { month, year };
            };

            const globalPlayerStats = useMemo(() => {
                const stats = {};
                if (!rawData || rawData.length === 0) return stats;
                rawData.forEach(log => {
                    const content = log.content || "";
                    const match = content.match(/^\[(.*?)\] (.*?) derrotou (.*)/);
                    if (match) {
                        const mode = match[1];
                        const winners = match[2].split(',').map(n => n.trim()).filter(n => n);
                        const losers = match[3].split(',').map(n => n.trim()).filter(n => n);
                        const participants = [...winners, ...losers];
                        participants.forEach(p => {
                            if (!stats[p]) stats[p] = { total: 0, modes: {} };
                            stats[p].total += 1;
                            if (!stats[p].modes[mode]) stats[p].modes[mode] = 0;
                            stats[p].modes[mode] += 1;
                        });
                    }
                });
                return stats;
            }, [rawData]);

            useEffect(() => {
                const favicon = document.getElementById('dynamic-favicon');
                if (favicon && CUSTOM_ICON_URL) favicon.href = CUSTOM_ICON_URL;
            }, []);

            const getRoundedTime = (timestamp) => {
                const date = new Date(timestamp);
                const hours = date.getHours().toString().padStart(2, '0');
                const minutes = date.getMinutes();
                const roundedMinutes = (Math.floor(minutes / 10) * 10).toString().padStart(2, '0');
                return `${hours}:${roundedMinutes}`;
            };

            const getShareLink = (target = null) => {
                const params = new URLSearchParams();
                params.set('view', viewMode);
                params.set('mode', activeTab);
                params.set('time', timeFilter);
                if (targetMonth) params.set('month', targetMonth);

                if (viewMode === 'versus') {
                    if (versusPlayer1) params.set('p1', versusPlayer1);
                    if (versusPlayer2) params.set('p2', versusPlayer2);
                } else if (target && target.name && target.matches) {
                    params.set('tournament', target.id);
                } else if (target && target.name && !target.matches) {
                    params.set('player', target.name);
                }
                return `${window.location.origin}${window.location.pathname}?${params.toString()}`;
            };

            useEffect(() => {
                const fetchData = async () => {
                    setIsLoading(true); setError(null);
                    const loadedData = [];
                    
                    try {
                        // Fetch Players Metadata from Firestore
                        try {
                            const playersSnapshot = await getDocs(collection(db, "players_metadata"));
                            const playersMap = {};
                            playersSnapshot.forEach(doc => {
                                const p = doc.data();
                                playersMap[p.name] = p;
                            });
                            setPlayersMetadata(playersMap);
                        } catch (err) { console.warn("Erro ao carregar players metadata:", err); }

                        // Fetch Battle Logs from Firestore (Ordering by timestamp for consistency)
                        // In a real scenario with thousands of docs, we might want to paginate or filter by date
                        // For now, we load all as per request
                        const logsQuery = query(collection(db, "battle_logs"), orderBy("timestamp", "asc"));
                        const logsSnapshot = await getDocs(logsQuery);
                        
                        logsSnapshot.forEach(doc => {
                            loadedData.push(doc.data());
                        });

                        setLoadedFilesCount(loadedData.length);
                        setRawData(loadedData);
                    } catch (err) { setError(`${t.error_loading}: ${err.message}`); setRawData([]); } finally { setIsLoading(false); }
                };
                fetchData();
            }, []);

            useEffect(() => {
                if (!isLoading && data.rankings.length > 0) {
                    const params = new URLSearchParams(window.location.search);
                    
                    const viewParam = params.get('view');
                    if (viewParam && ['ranking', 'versus', 'tournaments', 'masteries', 'villages'].includes(viewParam)) setViewMode(viewParam);

                    const modeParam = params.get('mode'); if (modeParam) setActiveTab(modeParam);
                    const timeParam = params.get('time'); if (timeParam) setTimeFilter(timeParam);
                    const monthParam = params.get('month'); if (monthParam) setTargetMonth(monthParam);

                    const playerParam = params.get('player');
                    const tournamentParam = params.get('tournament');
                    const p1Param = params.get('p1');
                    const p2Param = params.get('p2');

                    if (tournamentParam) {
                        const foundT = groupedTournaments.find(t => t.id === tournamentParam);
                        if (foundT) { setSelectedTournament(foundT); setViewMode('tournaments'); }
                    } else if (playerParam) {
                        const foundP = data.rankings.find(p => p.name.toLowerCase() === playerParam.toLowerCase());
                        if (foundP) {
                            const gStats = globalPlayerStats[foundP.name];
                            let globalBattles = 0;
                            if (gStats) {
                                if (modeParam === 'Geral' || !modeParam) globalBattles = gStats.total;
                                else if (modeParam === 'Ranked') globalBattles = (gStats.modes['Auto1v1'] || 0) + (gStats.modes['Auto2v2'] || 0) + (gStats.modes['Auto3v3'] || 0);
                                else globalBattles = gStats.modes[modeParam] || 0;
                            }
                            const currentBadges = foundP.badges ? foundP.badges.filter(b => b.id !== 'veteran' && b.id !== 'master') : [];
                            const newBadges = [...currentBadges];
                            if (globalBattles >= 1000) newBadges.push({ id: 'master', icon: ShurikenIcon, label: 'Ninja Mestre', color: 'text-yellow-400 drop-shadow-[0_0_3px_rgba(250,204,21,0.5)]' });
                            else if (globalBattles >= 100) newBadges.push({ id: 'veteran', icon: ShurikenIcon, label: 'Ninja Veterano', color: 'text-blue-400' });
                            
                            setSelectedPlayer({ ...foundP, badges: newBadges });
                        }
                    }

                    if (p1Param) setVersusPlayer1(p1Param);
                    if (p2Param) setVersusPlayer2(p2Param);
                    window.history.replaceState({}, document.title, window.location.pathname);
                }
            }, [isLoading, data.rankings, groupedTournaments]); 

            useEffect(() => {
                if (rawData.length === 0) { setData({ rankings: [], history: {} }); return; }
                const timestamps = rawData.map(l => l.timestamp ? new Date(l.timestamp).getTime() : 0).filter(t => t > 0);
                
                if (timestamps.length > 0) {
                    const minTime = Math.min(...timestamps);
                    const maxTime = Math.max(...timestamps);
                    setDateRange({ start: new Date(minTime).toLocaleDateString('pt-BR'), end: new Date(maxTime).toLocaleDateString('pt-BR') });
                    
                    const uniqueMonths = new Set();
                    rawData.forEach(log => {
                        if (log.timestamp) {
                            const d = new Date(log.timestamp);
                            const { month, year } = getRankingMonth(d);
                            const key = `${year}-${String(month + 1).padStart(2, '0')}`;
                            uniqueMonths.add(key);
                        }
                    });
                    
                    const sortedMonths = Array.from(uniqueMonths).sort().reverse();
                    setAvailableMonths(sortedMonths);
                    
                    // Default to current ranking month if available, else first available
                    const nowRanking = getRankingMonth(new Date());
                    const currentKey = `${nowRanking.year}-${String(nowRanking.month + 1).padStart(2, '0')}`;
                    
                    if (!targetMonth) {
                        if (uniqueMonths.has(currentKey)) {
                            setTargetMonth(currentKey);
                        } else if (sortedMonths.length > 0) {
                            setTargetMonth(sortedMonths[0]);
                        }
                    }
                }
            }, [rawData]);

            const referenceDate = useMemo(() => new Date(), []);
            
            const filteredLogs = useMemo(() => {
                return rawData.filter(log => {
                    if (timeFilter === 'all') return true;
                    if (!log.timestamp) return false;
                    
                    const logDate = new Date(log.timestamp);
                    const logTime = logDate.getTime();
                    const logRanking = getRankingMonth(logDate);

                    if (timeFilter === 'current_month') {
                        const refRanking = getRankingMonth(referenceDate);
                        return logRanking.month === refRanking.month && logRanking.year === refRanking.year;
                    }
                    
                    if (timeFilter === 'specific_month') {
                        if (!targetMonth) return true;
                        const [tYear, tMonth] = targetMonth.split('-').map(Number);
                        // tMonth is 1-12, logRanking.month is 0-11
                        return (logRanking.month + 1) === tMonth && logRanking.year === tYear;
                    }

                    const diff = referenceDate.getTime() - logTime;
                    const oneDay = 24 * 60 * 60 * 1000;
                    if (timeFilter === 'day') return diff <= oneDay && diff >= 0;
                    if (timeFilter === 'week') return diff <= 7 * oneDay && diff >= 0;
                    
                    return true;
                });
            }, [rawData, timeFilter, targetMonth, referenceDate]);

            useEffect(() => {
                const processed = processBattleLogs(filteredLogs);
                const enrichedRankings = processed.rankings.map(r => ({ ...r, meta: playersMetadata[r.name] || {} }));
                setData({ ...processed, rankings: enrichedRankings });
                setCurrentPage(1); 
            }, [filteredLogs, playersMetadata]);

            const modeGroups = useMemo(() => {
                if (filteredLogs.length === 0) return { main: ['Geral', 'Ranked'], others: [] };
                const modes = new Set();
                filteredLogs.forEach(log => {
                    const match = (log.content || "").match(/^\[(.*?)\]/);
                    if (match) modes.add(match[1]);
                });
                const allFoundModes = Array.from(modes);
                const mainModes = ['Geral', 'Ranked', ...PRIORITY_MODES.filter(m => modes.has(m))];
                const otherModes = allFoundModes.filter(m => !PRIORITY_MODES.includes(m)).sort();
                return { main: mainModes, others: otherModes };
            }, [filteredLogs]);

            const groupedTournaments = useMemo(() => {
                if (filteredLogs.length === 0) return [];
                const sortedLogs = [...filteredLogs].sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));
                const tournaments = [];
                const GAP_THRESHOLD = 90 * 60 * 1000; 
                sortedLogs.forEach(log => {
                    const content = log.content || "";
                    const match = content.match(/^\[(.*?)\] (.*?) derrotou (.*)/);
                    if (match && log.timestamp) {
                        const mode = match[1];
                        let isMatch = false;
                        if (activeTab === 'Geral') isMatch = true;
                        else if (activeTab === 'Ranked') { if (['Auto1v1', 'Auto2v2', 'Auto3v3'].includes(mode)) isMatch = true; } 
                        else if (mode === activeTab) { isMatch = true; }
                        if (!isMatch) return;

                        const logTime = new Date(log.timestamp).getTime();
                        let targetTournament = null;
                        for (let i = tournaments.length - 1; i >= 0; i--) {
                            if (tournaments[i].name === mode) {
                                const lastMatchTime = tournaments[i].lastMatchTimestamp;
                                if (logTime - lastMatchTime <= GAP_THRESHOLD) { targetTournament = tournaments[i]; }
                                break; 
                            }
                        }
                        const winners = match[2].split(',').map(n => n.trim()).filter(n => n.length > 0);
                        const losers = match[3].split(',').map(n => n.trim()).filter(n => n.length > 0);
                        const matchData = { winners, losers, timestamp: log.timestamp };
                        if (targetTournament) { targetTournament.matches.push(matchData); targetTournament.lastMatchTimestamp = logTime; } 
                        else { tournaments.push({ id: `${mode}-${log.timestamp}`, name: mode, date: new Date(log.timestamp).toLocaleDateString('pt-BR'), timestamp: logTime, lastMatchTimestamp: logTime, matches: [matchData] }); }
                    }
                });
                return tournaments.sort((a, b) => b.lastMatchTimestamp - a.lastMatchTimestamp);
            }, [filteredLogs, activeTab]);

            const tournamentStats = useMemo(() => {
                const stats = {};
                groupedTournaments.forEach(t => {
                    const sortedMatches = [...t.matches].sort((a,b) => new Date(a.timestamp) - new Date(b.timestamp));
                    const lastMatch = sortedMatches[sortedMatches.length - 1];
                    const participants = new Set();
                    t.matches.forEach(m => { m.winners.forEach(w => participants.add(w)); m.losers.forEach(l => participants.add(l)); });
                    participants.forEach(p => { if (!stats[p]) stats[p] = { wins: 0, played: 0 }; stats[p].played += 1; });
                    if (lastMatch) { lastMatch.winners.forEach(w => { if (!stats[w]) stats[w] = { wins: 0, played: 0 }; stats[w].wins += 1; }); }
                });
                return stats;
            }, [groupedTournaments]);

            const tournamentsByDate = useMemo(() => {
                const groups = {};
                groupedTournaments.forEach(t => {
                    if (!groups[t.date]) groups[t.date] = [];
                    groups[t.date].push(t);
                });
                return groups;
            }, [groupedTournaments]);

             const filteredRankings = useMemo(() => {
                let players = [...data.rankings];
                if (activeTab === 'Geral') {
                    players = players.map(p => { const tStats = tournamentStats[p.name] || { wins: 0, played: 0 }; return { ...p, tournamentWins: tStats.wins, tournamentsPlayed: tStats.played }; });
                } else if (activeTab === 'Ranked') {
                    players = players.map(p => {
                        let wins = 0, losses = 0, battles = 0;
                        const rankedModes = ['Auto1v1', 'Auto2v2', 'Auto3v3'];
                        rankedModes.forEach(m => { if (p.modes && p.modes[m]) { wins += p.modes[m].wins; losses += p.modes[m].losses; battles += p.modes[m].battles; } });
                        if (battles === 0) return null;
                        const tStats = tournamentStats[p.name] || { wins: 0, played: 0 };
                        return { ...p, wins, losses, battles, winRate: ((wins / battles) * 100).toFixed(1), tournamentWins: tStats.wins, tournamentsPlayed: tStats.played };
                    }).filter(p => p !== null);
                } else {
                    players = players.map(p => {
                        const modeStats = p.modes && p.modes[activeTab];
                        if (!modeStats) return null;
                        const tStats = tournamentStats[p.name] || { wins: 0, played: 0 };
                        return { ...p, wins: modeStats.wins, losses: modeStats.losses, battles: modeStats.battles, winRate: modeStats.battles > 0 ? ((modeStats.wins / modeStats.battles) * 100).toFixed(1) : 0, tournamentWins: tStats.wins, tournamentsPlayed: tStats.played };
                    }).filter(p => p !== null);
                }

                players = players.map(p => {
                    const gStats = globalPlayerStats[p.name];
                    let globalBattles = 0;
                    if (gStats) {
                        if (activeTab === 'Geral') globalBattles = gStats.total;
                        else if (activeTab === 'Ranked') globalBattles = (gStats.modes['Auto1v1'] || 0) + (gStats.modes['Auto2v2'] || 0) + (gStats.modes['Auto3v3'] || 0);
                        else globalBattles = gStats.modes[activeTab] || 0;
                    }
                    const newBadges = [...(p.badges || [])];
                    if (globalBattles >= 1000) newBadges.push({ id: 'master', icon: ShurikenIcon, label: t.icon_master, color: 'text-yellow-400 drop-shadow-[0_0_3px_rgba(250,204,21,0.5)]' });
                    else if (globalBattles >= 100) newBadges.push({ id: 'veteran', icon: ShurikenIcon, label: t.icon_veteran, color: 'text-blue-400' });
                    return { ...p, badges: newBadges };
                });

                if (searchTerm) players = players.filter(p => p.name.toLowerCase().includes(searchTerm.toLowerCase()));

                players.sort((a, b) => {
                    let aValue = a[sortConfig.key] || 0;
                    let bValue = b[sortConfig.key] || 0;
                    
                    if (sortConfig.key === 'winRate' || sortConfig.key === 'wins' || sortConfig.key === 'losses' || sortConfig.key === 'battles' || sortConfig.key === 'tournamentWins' || sortConfig.key === 'tournamentsPlayed') {
                        aValue = parseFloat(aValue);
                        bValue = parseFloat(bValue);
                    }

                    if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
                    if (sortConfig.key !== 'wins') return b.wins - a.wins;
                    return 0;
                });

                return players;
            }, [data.rankings, searchTerm, sortConfig, activeTab, globalPlayerStats, tournamentStats, t]);

            const paginatedRankings = useMemo(() => {
                const startIndex = (currentPage - 1) * ITEMS_PER_PAGE;
                return filteredRankings.slice(startIndex, startIndex + ITEMS_PER_PAGE);
            }, [filteredRankings, currentPage]);

            const totalPages = Math.ceil(filteredRankings.length / ITEMS_PER_PAGE);

            const groupedMasteries = useMemo(() => {
                const stats = {};
                const sourceData = filteredRankings; 
                if (masteryViewMode === 'individual') {
                    sourceData.forEach(p => {
                        const processM = (m) => {
                            if (!m) return;
                            if (!stats[m]) stats[m] = { name: m, parts: [m], wins: 0, losses: 0, battles: 0, players: 0 };
                            stats[m].wins += p.wins; stats[m].losses += p.losses; stats[m].battles += p.battles; stats[m].players += 1;
                        }
                        if (p.meta) { processM(p.meta.mastery_1); processM(p.meta.mastery_2); }
                    });
                } else {
                    sourceData.forEach(p => {
                        if (p.meta && (p.meta.mastery_1 || p.meta.mastery_2)) {
                            const m1 = p.meta.mastery_1; const m2 = p.meta.mastery_2;
                            let key; let displayParts = [];
                            if (m1 && m2) { const parts = [m1, m2].sort(); key = parts.join(' + '); displayParts = parts; } else { key = m1 || m2; displayParts = [key]; }
                            if (!stats[key]) stats[key] = { name: key, parts: displayParts, wins: 0, losses: 0, battles: 0, players: 0 };
                            stats[key].wins += p.wins; stats[key].losses += p.losses; stats[key].battles += p.battles; stats[key].players += 1;
                        }
                    });
                }
                
                const result = Object.values(stats).map(stat => ({
                    ...stat, winRate: stat.battles > 0 ? ((stat.wins / stat.battles) * 100).toFixed(1) : 0
                }));

                result.sort((a, b) => {
                    const validKeys = ['wins', 'losses', 'battles', 'winRate', 'players', 'name'];
                    const sortKey = validKeys.includes(sortConfig.key) ? sortConfig.key : 'wins';
                    
                    let aValue = a[sortKey];
                    let bValue = b[sortKey];

                    if (sortKey !== 'name') {
                        aValue = parseFloat(aValue);
                        bValue = parseFloat(bValue);
                    }

                    if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
                    return b.wins - a.wins;
                });

                return result;
            }, [filteredRankings, masteryViewMode, sortConfig]);

            const groupedVillages = useMemo(() => {
                const stats = {};
                filteredRankings.forEach(p => {
                    if (p.meta && p.meta.village) {
                        const v = p.meta.village;
                        if (!stats[v]) stats[v] = { name: v, wins: 0, losses: 0, battles: 0, players: 0 };
                        stats[v].wins += p.wins; stats[v].losses += p.losses; stats[v].battles += p.battles; stats[v].players += 1;
                    }
                });
                const result = Object.values(stats).map(stat => ({
                    ...stat, winRate: stat.battles > 0 ? ((stat.wins / stat.battles) * 100).toFixed(1) : 0
                }));

                 result.sort((a, b) => {
                    const validKeys = ['wins', 'losses', 'battles', 'winRate', 'players', 'name'];
                    const sortKey = validKeys.includes(sortConfig.key) ? sortConfig.key : 'wins';
                    
                    let aValue = a[sortKey];
                    let bValue = b[sortKey];

                    if (sortKey !== 'name') {
                        aValue = parseFloat(aValue);
                        bValue = parseFloat(bValue);
                    }

                    if (aValue < bValue) return sortConfig.direction === 'asc' ? -1 : 1;
                    if (aValue > bValue) return sortConfig.direction === 'asc' ? 1 : -1;
                    return b.wins - a.wins;
                });

                return result;
            }, [filteredRankings, sortConfig]);

            const handleSort = (key) => {
                let direction = 'desc';
                if (sortConfig.key === key && sortConfig.direction === 'desc') { direction = 'asc'; }
                setSortConfig({ key, direction });
            };

            const handleMasteryClick = (masteryName) => { setSelectedMastery(masteryName); };
            const handleVillageClick = (villageName) => { setSelectedVillage(villageName); };
            
            const handleOpenTournament = (mode, timestamp) => {
                const found = groupedTournaments.find(t => t.name === mode && t.matches.some(m => m.timestamp === timestamp));
                if (found) {
                    setSelectedTournament(found);
                    setSelectedPlayer(null); 
                }
            };

            const handlePlayerClick = (playerName) => {
                if (!data.rankings) return;
                let player = data.rankings.find(r => r.name === playerName);
                if (!player) player = { name: playerName, wins: 0, losses: 0, battles: 0, winRate: 0, badges: [] };
                const gStats = globalPlayerStats[playerName];
                let globalBattles = 0;
                if (gStats) {
                    if (activeTab === 'Geral') globalBattles = gStats.total;
                    else if (activeTab === 'Ranked') globalBattles = (gStats.modes['Auto1v1'] || 0) + (gStats.modes['Auto2v2'] || 0) + (gStats.modes['Auto3v3'] || 0);
                    else globalBattles = gStats.modes[activeTab] || 0;
                }
                const currentBadges = player.badges ? player.badges.filter(b => b.id !== 'veteran' && b.id !== 'master') : [];
                const newBadges = [...currentBadges];
                if (globalBattles >= 1000) newBadges.push({ id: 'master', icon: ShurikenIcon, label: t.icon_master, color: 'text-yellow-400 drop-shadow-[0_0_3px_rgba(250,204,21,0.5)]' });
                else if (globalBattles >= 100) newBadges.push({ id: 'veteran', icon: ShurikenIcon, label: t.icon_veteran, color: 'text-blue-400' });
                
                setSelectedPlayer({ ...foundP, badges: newBadges });
                setSelectedTournament(null); 
            };

            const selectedMasteryPlayers = useMemo(() => {
                if (!selectedMastery) return [];
                return filteredRankings.filter(p => {
                     if (masteryViewMode === 'individual') return p.meta?.mastery_1 === selectedMastery || p.meta?.mastery_2 === selectedMastery;
                     else {
                         const m1 = p.meta?.mastery_1; const m2 = p.meta?.mastery_2;
                         let key; if (m1 && m2) key = [m1, m2].sort().join(' + '); else key = m1 || m2;
                         return key === selectedMastery;
                     }
                }).sort((a,b) => b.wins - a.wins);
            }, [selectedMastery, filteredRankings, masteryViewMode]);

            const selectedVillagePlayers = useMemo(() => {
                if (!selectedVillage) return [];
                return filteredRankings.filter(p => p.meta?.village === selectedVillage).sort((a,b) => b.wins - a.wins);
            }, [selectedVillage, filteredRankings]);

            const totalBattles = filteredRankings.reduce((acc, curr) => acc + curr.wins, 0); 
            const mostWinsPlayer = useMemo(() => {
                if (filteredRankings.length === 0) return null;
                return [...filteredRankings].sort((a,b) => { if (b.wins !== a.wins) return b.wins - a.wins; return parseFloat(b.winRate) - parseFloat(a.winRate); })[0];
            }, [filteredRankings]);
            const mostLossesPlayer = useMemo(() => {
                if (filteredRankings.length === 0) return null;
                return [...filteredRankings].sort((a,b) => { if (b.losses !== a.losses) return b.losses - a.losses; return parseFloat(a.winRate) - parseFloat(b.winRate); })[0];
            }, [filteredRankings]);

            const versusMatches = useMemo(() => {
                if (!versusPlayer1 || !versusPlayer2 || viewMode !== 'versus') return [];
                return filteredLogs.filter(log => {
                    const content = log.content || "";
                    const match = content.match(/^\[(.*?)\] (.*?) derrotou (.*)/);
                    if (!match) return false;
                    const mode = match[1];
                    if (activeTab !== 'Geral') {
                        if (activeTab === 'Ranked') { if (!['Auto1v1', 'Auto2v2', 'Auto3v3'].includes(mode)) return false; } 
                        else { if (mode !== activeTab) return false; }
                    }
                    const winnersStr = match[2]; const losersStr = match[3];
                    const winners = winnersStr.split(',').map(n => n.trim()); const losers = losersStr.split(',').map(n => n.trim());
                    const p1InWinners = winners.includes(versusPlayer1); const p2InLosers = losers.includes(versusPlayer2);
                    const p2InWinners = winners.includes(versusPlayer2); const p1InLosers = losers.includes(versusPlayer1);
                    return (p1InWinners && p2InLosers) || (p2InWinners && p1InLosers);
                }).sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
            }, [filteredLogs, versusPlayer1, versusPlayer2, viewMode, activeTab]);

            const versusStats = useMemo(() => {
                let p1Wins = 0; let p2Wins = 0;
                versusMatches.forEach(log => {
                    const match = log.content.match(/^\[(.*?)\] (.*?) derrotou (.*)/);
                    const winners = match[2].split(',').map(n => n.trim());
                    if (winners.includes(versusPlayer1)) p1Wins++; else p2Wins++;
                });
                return { p1Wins, p2Wins, total: versusMatches.length };
            }, [versusMatches, versusPlayer1]);


            // --- RENDER ---
            if (isLoading) return (<div className="min-h-screen bg-slate-950 flex flex-col items-center justify-center p-8"><div className="w-full max-w-md space-y-4"><div className="flex justify-between items-end"><div className="space-y-2"><Skeleton className="h-8 w-48" /><Skeleton className="h-4 w-32" /></div><Loader2 className="w-8 h-8 animate-spin text-yellow-500" /></div><Skeleton className="h-32 w-full rounded-xl" /><div className="space-y-2"><Skeleton className="h-12 w-full" /><Skeleton className="h-12 w-full" /><Skeleton className="h-12 w-full" /></div><div className="text-center text-xs text-slate-500 pt-4">{t.loading} {loadedFilesCount}</div></div></div>);
            if (error) return (<div className="min-h-screen bg-slate-950 flex flex-col items-center justify-center text-red-400 p-8 text-center"><AlertCircle className="w-16 h-16 mb-4" /><h2 className="text-2xl font-bold mb-2">{t.error_loading}</h2><p className="max-w-md">{error}</p><button onClick={() => window.location.reload()} className="mt-6 px-6 py-2 bg-slate-800 rounded-lg hover:bg-slate-700 transition-colors text-white">{t.try_again}</button></div>);

            return (
                <div className="min-h-screen bg-slate-950 text-slate-100 font-sans p-4 md:p-8 pb-16"> 
                    {showInfoModal && <InfoModal onClose={() => setShowInfoModal(false)} t={t} />}
                    {showUploadModal && <UploadModal onClose={() => setShowUploadModal(false)} t={t} />}
                    
                    {selectedPlayer && (
                        <PlayerModal 
                            player={selectedPlayer} 
                            history={data.history} 
                            tournaments={groupedTournaments}
                            activeTab={activeTab} 
                            onClose={() => setSelectedPlayer(null)} 
                            onNavigateToPlayer={handlePlayerClick}
                            onOpenTournament={(t) => { setSelectedTournament(t); setSelectedPlayer(null); }} 
                            getShareLink={getShareLink}
                            t={t}
                        />
                    )}
                    {selectedTournament && <TournamentBracketModal tournament={selectedTournament} onClose={() => setSelectedTournament(null)} onPlayerClick={handlePlayerClick} getShareLink={getShareLink} t={t} />}
                    {selectedMastery && <MasteryDetailsModal mastery={selectedMastery} players={selectedMasteryPlayers} onClose={() => setSelectedMastery(null)} onPlayerClick={(player) => { setSelectedPlayer(player); }} t={t} />}
                    {selectedVillage && <VillageDetailsModal village={selectedVillage} players={selectedVillagePlayers} onClose={() => setSelectedVillage(null)} onPlayerClick={(player) => { setSelectedPlayer(player); }} t={t} />}

                    <div className="max-w-7xl mx-auto space-y-8 animate-in fade-in slide-in-from-bottom-8 duration-700">
                        {/* Header */}
                        <div className="flex flex-col lg:flex-row justify-between items-center border-b border-slate-800 pb-6 gap-6 relative">
                            <div className="flex items-center gap-4 w-full lg:w-auto">
                                <img src={CUSTOM_ICON_URL} alt="Logo" className="w-20 h-20 object-cover rounded-2xl" onError={(e) => { e.target.style.display = 'none'; e.target.nextSibling.style.display = 'flex'; }} />
                                <div className="hidden bg-gradient-to-br from-yellow-500 to-orange-600 p-4 rounded-2xl shadow-lg shadow-orange-500/20 flex items-center justify-center w-20 h-20"><Trophy className="w-10 h-10 text-white" /></div>
                                <div className="flex flex-col gap-1">
                                    <div className="flex items-center gap-3"><h1 className="text-4xl font-black text-white tracking-tight">Nin Online <span className="text-transparent bg-clip-text bg-gradient-to-r from-yellow-400 to-orange-500">Tournaments</span></h1><div className="flex items-center gap-2"><button onClick={() => setShowInfoModal(true)} className="bg-slate-800 p-1.5 rounded-full hover:bg-slate-700 transition-colors text-slate-400 hover:text-blue-400 border border-slate-700" title="Como usar / Sobre"><HelpCircle className="w-5 h-5" /></button><ShareButton generateUrl={() => getShareLink()} className="bg-slate-800 hover:bg-slate-700 text-slate-400 hover:text-white border border-slate-700 h-8" label={t.share} /><LanguageSwitcher currentLang={language} setLang={setLanguage} /></div></div>
                                    <div className="flex flex-wrap gap-2 mt-1">
                                        <div className="inline-flex items-center gap-1.5 px-3 py-1 bg-slate-800 rounded-full border border-slate-700 text-xs font-bold text-slate-300"><ServerIcon className="w-3 h-3 text-blue-400" /><span>{t.server}</span></div>
                                        {dateRange.start && (<div className="inline-flex items-center gap-1.5 px-3 py-1 bg-slate-800 rounded-full border border-slate-700 text-xs font-bold text-slate-300"><Calendar className="w-3 h-3 text-yellow-500" /><span>{dateRange.start} {t.to} {dateRange.end}</span></div>)}
                                    </div>
                                </div>
                            </div>
                            
                            {/* Login / Admin Panel */}
                            <div className="w-full lg:w-auto bg-slate-900 border border-slate-800 rounded-2xl p-4 flex flex-col sm:flex-row items-center gap-4 relative overflow-hidden group shadow-lg">
                                {!user ? (
                                    <form onSubmit={handleLogin} className="flex flex-col sm:flex-row items-center gap-3 z-10">
                                        <div className="flex flex-col gap-2">
                                            <input type="email" name="email" placeholder="Email" className="bg-slate-800 border border-slate-700 rounded px-3 py-1.5 text-xs text-white placeholder-slate-500 focus:outline-none focus:border-blue-500 transition-colors w-48" required />
                                            <input type="password" name="password" placeholder="Senha" className="bg-slate-800 border border-slate-700 rounded px-3 py-1.5 text-xs text-white placeholder-slate-500 focus:outline-none focus:border-blue-500 transition-colors w-48" required />
                                        </div>
                                        <button type="submit" className="h-full py-4 px-4 bg-blue-600 hover:bg-blue-500 text-white text-xs font-bold rounded-lg transition-colors flex items-center justify-center gap-2 whitespace-nowrap shadow-lg shadow-blue-900/20">
                                            <LogIn className="w-4 h-4" />
                                            <span>{t.login_btn}</span>
                                        </button>
                                    </form>
                                ) : (
                                    <>
                                        <div className="flex items-center gap-3 z-10">
                                            <img src={user.photoURL || CUSTOM_ICON_URL} alt={user.displayName || "Admin"} className="w-10 h-10 rounded-full border border-slate-700 bg-slate-800" />
                                            <div className="flex flex-col">
                                                <h3 className="text-white font-bold text-sm truncate max-w-[120px]">{user.email}</h3>
                                                <button onClick={handleLogout} className="text-red-400 text-xs hover:underline text-left flex items-center gap-1"><LogOut className="w-3 h-3" /> {t.logout}</button>
                                            </div>
                                        </div>
                                        <button onClick={() => setShowUploadModal(true)} className="z-10 px-4 py-2 bg-green-600 hover:bg-green-500 text-white text-xs font-bold rounded-lg transition-colors flex items-center gap-2 whitespace-nowrap ml-2">
                                            <UploadCloud className="w-4 h-4" />
                                            <span>{t.upload_data}</span>
                                        </button>
                                    </>
                                )}
                            </div>
                        </div>

                        {/* Search & Tabs */}
                        <div className="w-full"><div className="relative group w-full"><div className="absolute inset-y-0 left-0 pl-4 flex items-center pointer-events-none"><Search className="w-6 h-6 text-slate-500 group-focus-within:text-yellow-500 transition-colors" /></div><input type="text" placeholder={t.search_placeholder} className="w-full bg-slate-900 border border-slate-800 text-slate-200 rounded-xl py-4 pl-12 pr-4 focus:outline-none focus:ring-2 focus:ring-yellow-500/50 focus:border-yellow-500 transition-all shadow-lg text-lg" value={searchTerm} onChange={(e) => { setSearchTerm(e.target.value); setCurrentPage(1); }} /></div></div>
                        <div className="flex gap-2 overflow-x-auto pb-2 scrollbar-hide">
                            <button onClick={() => setViewMode('ranking')} className={`px-5 py-3 rounded-lg font-bold text-sm transition-colors flex items-center gap-2 whitespace-nowrap ${viewMode === 'ranking' ? 'bg-yellow-500 text-slate-900 shadow-lg shadow-yellow-500/20' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}><Trophy className="w-4 h-4" /> {t.ranking}</button>
                            <button onClick={() => setViewMode('versus')} className={`px-5 py-3 rounded-lg font-bold text-sm transition-colors flex items-center gap-2 whitespace-nowrap ${viewMode === 'versus' ? 'bg-yellow-500 text-slate-900 shadow-lg shadow-yellow-500/20' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}><Swords className="w-4 h-4" /> {t.versus}</button>
                            <button onClick={() => setViewMode('tournaments')} className={`px-5 py-3 rounded-lg font-bold text-sm transition-colors flex items-center gap-2 whitespace-nowrap ${viewMode === 'tournaments' ? 'bg-yellow-500 text-slate-900 shadow-lg shadow-yellow-500/20' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}><GitBranch className="w-4 h-4" /> {t.tournaments}</button>
                            <button onClick={() => setViewMode('masteries')} className={`px-5 py-3 rounded-lg font-bold text-sm transition-colors flex items-center gap-2 whitespace-nowrap ${viewMode === 'masteries' ? 'bg-yellow-500 text-slate-900 shadow-lg shadow-yellow-500/20' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}><BookOpen className="w-4 h-4" /> {t.masteries}</button>
                            <button onClick={() => setViewMode('villages')} className={`px-5 py-3 rounded-lg font-bold text-sm transition-colors flex items-center gap-2 whitespace-nowrap ${viewMode === 'villages' ? 'bg-yellow-500 text-slate-900 shadow-lg shadow-yellow-500/20' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}><MapIcon className="w-4 h-4" /> {t.villages}</button>
                        </div>

                        {/* Filters */}
                        <div className="flex flex-col gap-3 pb-2 border-b border-slate-800">
                            <div className="flex flex-wrap items-center gap-2">
                                <div className="flex flex-wrap gap-2">
                                    {modeGroups.main.map(mode => (<button key={mode} onClick={() => { setActiveTab(mode); setShowOtherModes(false); }} className={`px-4 py-2 rounded-lg text-sm font-bold whitespace-nowrap transition-all flex items-center gap-2 ${activeTab === mode ? 'bg-blue-600 text-white shadow-md' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}>{mode === 'Geral' ? <Filter className="w-3.5 h-3.5" /> : mode === 'Ranked' ? <ShieldCheck className="w-3.5 h-3.5" /> : <Swords className="w-3.5 h-3.5" />}{mode === 'Geral' && language === 'en' ? 'General' : mode}</button>))}
                                    {modeGroups.others.length > 0 && (<div className="relative"><button onClick={() => setShowOtherModes(!showOtherModes)} className={`px-4 py-2 rounded-lg text-sm font-bold whitespace-nowrap transition-all flex items-center gap-2 ${modeGroups.others.includes(activeTab) ? 'bg-blue-600 text-white shadow-md' : 'bg-slate-800 text-slate-400 hover:bg-slate-700 hover:text-white'}`}><Menu className="w-3.5 h-3.5" />{modeGroups.others.includes(activeTab) ? activeTab : t.others}<ChevronDown className={`w-3.5 h-3.5 transition-transform ${showOtherModes ? 'rotate-180' : ''}`} /></button>{showOtherModes && (<div className="absolute top-full left-0 mt-2 w-48 bg-slate-900 border border-slate-800 rounded-xl shadow-xl z-20 overflow-hidden animate-in fade-in slide-in-from-top-2 duration-200">{modeGroups.others.map(mode => (<button key={mode} onClick={() => { setActiveTab(mode); setShowOtherModes(false); }} className={`w-full text-left px-4 py-3 text-sm font-medium transition-colors hover:bg-slate-800 ${activeTab === mode ? 'text-yellow-500 bg-slate-800/50' : 'text-slate-400 hover:text-white'}`}>{mode}</button>))}</div>)}</div>)}
                                </div>
                                <div className="flex flex-row items-center gap-2 ml-auto">
                                    <div className="relative group w-40 sm:w-48"><div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><Calendar className="w-4 h-4 text-slate-500" /></div><select value={timeFilter} onChange={(e) => setTimeFilter(e.target.value)} className="appearance-none w-full bg-slate-900 border border-slate-800 text-slate-200 rounded-lg py-2 pl-9 pr-8 focus:outline-none focus:ring-2 focus:ring-blue-500/50 cursor-pointer hover:bg-slate-800 transition-colors text-sm font-medium"><option value="current_month">{t.current_month}</option><option value="day">{t.day}</option><option value="week">{t.week}</option><option value="specific_month">{t.specific_month}</option><option value="all">{t.all}</option></select><div className="absolute inset-y-0 right-0 pr-2 flex items-center pointer-events-none"><ChevronDown className="w-4 h-4 text-slate-500" /></div></div>
                                    {timeFilter === 'specific_month' && availableMonths.length > 0 && (<div className="relative group w-32 sm:w-40 animate-in fade-in slide-in-from-left-2 duration-200"><select value={targetMonth} onChange={(e) => setTargetMonth(e.target.value)} className="appearance-none w-full bg-slate-800 border border-slate-700 text-slate-200 rounded-lg py-2 px-3 focus:outline-none focus:ring-2 focus:ring-blue-500/50 cursor-pointer text-sm font-medium">{availableMonths.map(monthStr => { const [year, month] = monthStr.split('-'); return (<option key={monthStr} value={monthStr}>{`${month}/${year}`}</option>); })}</select><div className="absolute inset-y-0 right-0 pr-2 flex items-center pointer-events-none"><ChevronDown className="w-3 h-3 text-slate-500" /></div></div>)}
                                </div>
                            </div>
                            <div className="text-slate-400 text-sm flex items-start gap-2 pl-1 animate-in fade-in duration-300"><InfoIcon className="w-4 h-4 mt-0.5 text-slate-500 flex-shrink-0" /><p>{MODE_DESCRIPTIONS[activeTab] || t.default_desc}</p></div>
                        </div>

                        {/* Views */}
                        {viewMode === 'versus' && (
                             <div className="bg-slate-900 rounded-2xl shadow-xl overflow-hidden border border-slate-800 animate-in fade-in slide-in-from-bottom-4 duration-500 p-6">
                                <div className="flex flex-col md:flex-row gap-4 items-end mb-8 relative">
                                    <div className="absolute top-0 right-0"><ShareButton generateUrl={() => getShareLink()} className="bg-slate-800 hover:bg-slate-700 text-slate-300 border border-slate-700" label={t.share} /></div>
                                    <div className="flex-1 w-full"><label className="block text-slate-400 text-sm font-bold mb-2">{t.player1}</label><div className="relative"><div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><Users className="w-5 h-5 text-blue-400" /></div><input type="text" list="playerList" className="w-full bg-slate-800 border border-slate-700 text-white rounded-xl py-3 pl-10 pr-4 focus:outline-none focus:ring-2 focus:ring-blue-500/50" placeholder={t.player1} value={versusPlayer1} onChange={(e) => setVersusPlayer1(e.target.value)} /></div></div>
                                    <div className="flex items-center justify-center pb-3"><div className="bg-slate-800 p-2 rounded-full border border-slate-700"><Swords className="w-6 h-6 text-red-500" /></div></div>
                                    <div className="flex-1 w-full"><label className="block text-slate-400 text-sm font-bold mb-2">{t.player2}</label><div className="relative"><div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none"><Users className="w-5 h-5 text-red-400" /></div><input type="text" list="playerList" className="w-full bg-slate-800 border border-slate-700 text-white rounded-xl py-3 pl-10 pr-4 focus:outline-none focus:ring-2 focus:ring-red-500/50" placeholder={t.player2} value={versusPlayer2} onChange={(e) => setVersusPlayer2(e.target.value)} /></div></div>
                                    <datalist id="playerList">{data.rankings.map(p => <option key={p.name} value={p.name} />)}</datalist>
                                </div>
                                {versusMatches.length > 0 ? (
                                    <React.Fragment>
                                        <div className="mb-8 space-y-4"><div className="flex items-center gap-3"><span className="text-xs text-blue-400 font-bold w-12 text-right">{((versusStats.p1Wins/versusStats.total)*100).toFixed(0)}%</span><div className="flex-1 h-2 bg-slate-800 rounded-full overflow-hidden flex"><div style={{ width: `${(versusStats.p1Wins/versusStats.total)*100}%` }} className="h-full bg-blue-500"></div><div style={{ width: `${(versusStats.p2Wins/versusStats.total)*100}%` }} className="h-full bg-red-500"></div></div><span className="text-xs text-red-400 font-bold w-12">{((versusStats.p2Wins/versusStats.total)*100).toFixed(0)}%</span></div></div>
                                        <div className="flex justify-center items-center gap-8 mb-8"><div className="text-center"><div className="text-4xl font-black text-blue-500">{versusStats.p1Wins}</div><div className="text-xs text-slate-400 font-bold uppercase tracking-wider">{versusPlayer1}</div></div><div className="text-slate-600 text-2xl font-black">X</div><div className="text-center"><div className="text-4xl font-black text-red-500">{versusStats.p2Wins}</div><div className="text-xs text-slate-400 font-bold uppercase tracking-wider">{versusPlayer2}</div></div></div>
                                        <div className="space-y-3">{versusMatches.map((match, idx) => { const m = match.content.match(/^\[(.*?)\] (.*?) derrotou (.*)/); if (!m) return null; const mode = m[1]; const winners = m[2].split(',').map(n => n.trim()); const losers = m[3].split(',').map(n => n.trim()); const isP1Winner = winners.includes(versusPlayer1); return (<div key={idx} onClick={() => handleOpenTournament(mode, match.timestamp)} className={`p-4 rounded-xl border flex flex-col md:flex-row justify-between items-start md:items-center gap-4 relative group cursor-pointer transition-all hover:shadow-lg ${isP1Winner ? 'bg-blue-900/10 border-blue-500/20 hover:border-blue-500/40' : 'bg-red-900/10 border-red-500/20 hover:border-red-500/40'}`}><div className="absolute -top-3 left-1/2 -translate-x-1/2 bg-slate-900 text-yellow-500 text-[10px] font-bold px-3 py-1 rounded-full border border-yellow-500/30 opacity-0 group-hover:opacity-100 transition-all transform translate-y-2 group-hover:translate-y-0 shadow-xl z-10 flex items-center gap-1"><Trophy className="w-3 h-3" /> {t.see_tournament}</div><div className="flex flex-col gap-2 flex-1 w-full"><div className="text-[10px] font-bold uppercase tracking-wider text-slate-500 flex items-center gap-1 w-fit">{mode}</div><div className="flex flex-col gap-1.5 w-full"><div className="flex flex-wrap items-center gap-1 text-sm bg-slate-950/30 p-2 rounded border border-slate-800/50"><span className="text-green-500 font-bold text-[10px] uppercase mr-1 bg-green-500/10 px-1 rounded border border-green-500/20">{t.winners}</span>{winners.map((name, i) => { const isTarget = name === versusPlayer1 || name === versusPlayer2; const colorClass = name === versusPlayer1 ? 'text-blue-400' : name === versusPlayer2 ? 'text-red-400' : 'text-slate-400'; return (<span key={i} onClick={(e) => { e.stopPropagation(); handlePlayerClick(name); }} className={`${colorClass} hover:underline hover:text-white cursor-pointer transition-colors ${isTarget ? 'font-black text-base border-b-2 border-current' : 'font-medium'}`} title="Ver histórico do jogador">{name}{i < winners.length - 1 ? ',' : ''}</span>); })}</div><div className="flex flex-wrap items-center gap-1 text-sm bg-slate-950/30 p-2 rounded border border-slate-800/50"><span className="text-red-500 font-bold text-[10px] uppercase mr-1 bg-red-500/10 px-1 rounded border border-red-500/20">{t.losers}</span>{losers.map((name, i) => { const isTarget = name === versusPlayer1 || name === versusPlayer2; const colorClass = name === versusPlayer1 ? 'text-blue-400' : name === versusPlayer2 ? 'text-red-400' : 'text-slate-500'; return (<span key={i} onClick={(e) => { e.stopPropagation(); handlePlayerClick(name); }} className={`${colorClass} hover:underline hover:text-white cursor-pointer transition-colors ${isTarget ? 'font-black text-base border-b-2 border-current' : 'font-medium'}`} title="Ver histórico do jogador">{name}{i < losers.length - 1 ? ',' : ''}</span>); })}</div></div></div><div className="text-right flex-shrink-0 flex md:flex-col items-center md:items-end justify-between w-full md:w-auto mt-2 md:mt-0 border-t md:border-t-0 border-slate-800 pt-2 md:pt-0"><div className={`text-sm font-black px-3 py-1 rounded border ${isP1Winner ? 'text-blue-400 bg-blue-500/10 border-blue-500/20' : 'text-red-400 bg-red-500/10 border-red-500/20'}`}>{isP1Winner ? t.victory_p1 : t.defeat_p1}</div><div className="text-xs text-slate-500 mt-1 font-mono">{new Date(match.timestamp).toLocaleDateString('pt-BR')}</div></div></div>); })}</div>
                                    </React.Fragment>
                                ) : ((versusPlayer1 && versusPlayer2) && (<div className="text-center py-12 text-slate-500 border border-dashed border-slate-800 rounded-xl"><Swords className="w-12 h-12 mx-auto mb-3 opacity-20" /><p>{t.no_match}</p></div>))}
                            </div>
                        )}
                        
                        {viewMode === 'ranking' && (
                            <React.Fragment>
                                <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
                                    <Card title={t.active_players} value={filteredRankings.length} icon={Users} colorClass="text-blue-400 bg-blue-500" />
                                    <Card title={t.total_battles} value={totalBattles} icon={Swords} colorClass="text-red-400 bg-red-500" />
                                    <Card title={t.most_wins} value={mostWinsPlayer ? mostWinsPlayer.name : '-'} icon={Medal} colorClass="text-yellow-400 bg-yellow-500" />
                                    <Card title={t.most_losses} value={mostLossesPlayer ? mostLossesPlayer.name : '-'} icon={TrendingDown} colorClass="text-orange-400 bg-orange-500" />
                                </div>
                                <div className="bg-slate-900 rounded-2xl shadow-xl overflow-hidden border border-slate-800">
                                    <div className="overflow-x-auto">
                                        <table className="w-full text-left border-collapse">
                                            <thead>
                                                <tr className="bg-slate-950/50 border-b border-slate-800 text-slate-400 text-xs font-bold uppercase tracking-wider">
                                                    <th className="p-5 w-20 text-center">#</th>
                                                    <th className="p-5 cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('name')}>{t.player} <SortIndicator active={sortConfig.key === 'name'} direction={sortConfig.direction} /></th>
                                                    <th className="p-5 text-center cursor-pointer hover:text-yellow-400 transition-colors" onClick={() => handleSort('tournamentWins')}>{t.t_wins} <SortIndicator active={sortConfig.key === 'tournamentWins'} direction={sortConfig.direction} /></th>
                                                    <th className="p-5 text-center cursor-pointer hover:text-blue-400 transition-colors" onClick={() => handleSort('tournamentsPlayed')}>{t.t_played} <SortIndicator active={sortConfig.key === 'tournamentsPlayed'} direction={sortConfig.direction} /></th>
                                                    <th className="p-5 text-center cursor-pointer hover:text-green-400 transition-colors" onClick={() => handleSort('wins')}>{t.wins} <SortIndicator active={sortConfig.key === 'wins'} direction={sortConfig.direction} /></th>
                                                    <th className="p-5 text-center cursor-pointer hover:text-red-400 transition-colors" onClick={() => handleSort('losses')}>{t.losses} <SortIndicator active={sortConfig.key === 'losses'} direction={sortConfig.direction} /></th>
                                                    <th className="p-5 text-center cursor-pointer hover:text-blue-400 transition-colors" onClick={() => handleSort('battles')}>{t.battles} <SortIndicator active={sortConfig.key === 'battles'} direction={sortConfig.direction} /></th>
                                                    <th className="p-5 text-center cursor-pointer hover:text-green-400 transition-colors" onClick={() => handleSort('winRate')}>{t.win_rate} <SortIndicator active={sortConfig.key === 'winRate'} direction={sortConfig.direction} /></th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-slate-800">
                                                {paginatedRankings.map((player, index) => {
                                                    let rankColor = "text-slate-500", rankIcon = null;
                                                    const realRank = (currentPage - 1) * ITEMS_PER_PAGE + index + 1;
                                                    if (realRank === 1) { rankColor = "text-yellow-500"; rankIcon = <Trophy className="w-4 h-4 mx-auto" />; }
                                                    if (realRank === 2) { rankColor = "text-slate-300"; rankIcon = <Medal className="w-4 h-4 mx-auto" />; }
                                                    if (realRank === 3) { rankColor = "text-amber-700"; rankIcon = <Medal className="w-4 h-4 mx-auto" />; }
                                                    const hasData = player.meta && (player.meta.village || player.meta.mastery_1);

                                                    return (
                                                        <tr key={player.name} onClick={() => setSelectedPlayer(player)} className="hover:bg-slate-800/50 cursor-pointer transition-colors group">
                                                            <td className={`p-5 text-center font-bold ${rankColor} text-lg`}>{rankIcon || `#${realRank}`}</td>
                                                            <td className="p-5">
                                                                <div className="flex flex-col">
                                                                    <div className="flex items-center gap-2">
                                                                        <span className="font-semibold text-white group-hover:text-yellow-400 transition-colors text-lg">{player.name}</span>
                                                                        {player.streak >= 3 && <span title={`${player.streak} ${t.icon_streak_win}`}><Flame className="w-4 h-4 text-orange-500 animate-pulse" /></span>}
                                                                        {player.streak <= -3 && <span title={`${Math.abs(player.streak)} ${t.icon_streak_loss}`}><Skull className="w-4 h-4 text-slate-500" /></span>}
                                                                        {player.badges.map(b => (<b.icon key={b.id} className={`w-3.5 h-3.5 ${b.color}`} title={b.label} />))}
                                                                    </div>
                                                                    {hasData ? (
                                                                        <div className="flex flex-wrap gap-1 mt-1">
                                                                                {player.meta.village && (<span className={`text-[10px] font-bold px-1.5 py-0.5 rounded border border-slate-700 bg-slate-800/50 uppercase tracking-wide ${STYLE_MAP[player.meta.village] || 'text-slate-400'}`}>{player.meta.village}</span>)}
                                                                                {player.meta.mastery_1 && (<span className={`text-[10px] font-bold px-1.5 py-0.5 rounded border uppercase tracking-wide ${STYLE_MAP[player.meta.mastery_1] || 'bg-slate-800 text-slate-400 border-slate-700'}`}>{player.meta.mastery_1}</span>)}
                                                                                {player.meta.mastery_2 && (<span className={`text-[10px] font-bold px-1.5 py-0.5 rounded border uppercase tracking-wide ${STYLE_MAP[player.meta.mastery_2] || 'bg-slate-800 text-slate-400 border-slate-700'}`}>{player.meta.mastery_2}</span>)}
                                                                        </div>
                                                                    ) : (<span className="text-[10px] text-slate-600 bg-slate-900/50 px-2 py-0.5 rounded border border-slate-800 w-fit mt-1">Sem Registro</span>)}
                                                                </div>
                                                            </td>
                                                            <td className="p-5 text-center font-bold text-yellow-500 text-lg">{player.tournamentWins}</td>
                                                            <td className="p-5 text-center text-slate-400">{player.tournamentsPlayed}</td>
                                                            <td className="p-5 text-center font-bold text-slate-200">{player.wins}</td>
                                                            <td className="p-5 text-center font-medium text-slate-500">{player.losses}</td>
                                                            <td className="p-5 text-center text-slate-400">{player.battles}</td>
                                                            <td className="p-5 text-center"><div className="flex flex-col items-center gap-1"><span className={`text-xs font-bold px-2 py-1 rounded-full ${parseFloat(player.winRate) >= 60 ? 'bg-green-500/20 text-green-400' : parseFloat(player.winRate) >= 40 ? 'bg-yellow-500/20 text-yellow-400' : 'bg-red-500/20 text-red-400'}`}>{player.winRate}%</span></div></td>
                                                        </tr>
                                                    );
                                                })}
                                                {filteredRankings.length === 0 && (<tr><td colSpan="8" className="p-12 text-center text-slate-500"><div className="flex flex-col items-center gap-3"><Users className="w-12 h-12 text-slate-700" /><p>{t.no_player_found}</p></div></td></tr>)}
                                            </tbody>
                                        </table>
                                    </div>
                                    {totalPages > 1 && (<div className="p-4 border-t border-slate-800 flex justify-center items-center gap-4 bg-slate-900"><button onClick={() => setCurrentPage(prev => Math.max(prev - 1, 1))} disabled={currentPage === 1} className="p-2 rounded-lg bg-slate-800 hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed text-slate-400 transition-colors"><ChevronLeft className="w-5 h-5" /></button><span className="text-sm text-slate-400 font-medium">Página <span className="text-white font-bold">{currentPage}</span> de {totalPages}</span><button onClick={() => setCurrentPage(prev => Math.min(prev + 1, totalPages))} disabled={currentPage === totalPages} className="p-2 rounded-lg bg-slate-800 hover:bg-slate-700 disabled:opacity-50 disabled:cursor-not-allowed text-slate-400 transition-colors"><ChevronRight className="w-5 h-5" /></button></div>)}
                                </div>
                            </React.Fragment>
                        )}
                        
                        {viewMode === 'tournaments' && (
                            <div className="bg-slate-900 rounded-2xl shadow-xl overflow-hidden border border-slate-800 animate-in fade-in slide-in-from-bottom-4 duration-500">
                                <div className="overflow-x-auto">
                                    <table className="w-full text-left border-collapse">
                                        <thead><tr className="bg-slate-950/50 border-b border-slate-800 text-slate-400 text-xs font-bold uppercase tracking-wider"><th className="p-5">{t.date}</th><th className="p-5">{t.tournament}</th><th className="p-5 text-center">{t.battles}</th><th className="p-5 text-right">{t.time}</th></tr></thead>
                                        <tbody className="divide-y divide-slate-800">
                                            {Object.entries(tournamentsByDate).map(([date, tournaments]) => (
                                                <React.Fragment key={date}>
                                                    <tr className="bg-slate-900/80 border-b border-slate-800"><td colSpan="4" className="p-3 px-5 text-yellow-500 font-bold text-xs uppercase tracking-wider sticky top-0 bg-slate-950/90 backdrop-blur-sm z-10">{date}</td></tr>
                                                    {tournaments.map(tournament => (<tr key={tournament.id} onClick={() => setSelectedTournament(tournament)} className="hover:bg-slate-800/50 cursor-pointer transition-colors group"><td className="p-5 text-slate-400 font-mono text-sm"><div className="flex items-center gap-2"><Calendar className="w-4 h-4 text-slate-600" />{tournament.date}</div></td><td className="p-5 font-bold text-white group-hover:text-yellow-400 transition-colors text-lg">{tournament.name}</td><td className="p-5 text-center text-slate-400"><span className="bg-slate-800 px-3 py-1 rounded-full text-xs font-bold border border-slate-700">{tournament.matches.length} {t.battles}</span></td><td className="p-5 text-right text-slate-500 group-hover:text-white transition-colors"><div className="flex items-center justify-end gap-2 font-mono text-sm"><Clock className="w-4 h-4 text-slate-600" />{getRoundedTime(tournament.timestamp)}</div></td></tr>))}
                                                </React.Fragment>
                                            ))}
                                            {groupedTournaments.length === 0 && (<tr><td colSpan="4" className="p-12 text-center text-slate-500"><div className="flex flex-col items-center gap-3"><Trophy className="w-12 h-12 text-slate-700 opacity-50" /><p>{t.no_tournament_found}</p></div></td></tr>)}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}

                        {viewMode === 'masteries' && (
                            <div className="bg-slate-900 rounded-2xl shadow-xl overflow-hidden border border-slate-800 animate-in fade-in slide-in-from-bottom-4 duration-500">
                                <div className="bg-slate-900/50 border-b border-yellow-500/20 px-6 py-3 flex items-start gap-3"><AlertCircle className="w-5 h-5 text-yellow-500 flex-shrink-0 mt-0.5" /><p className="text-xs text-slate-400 leading-relaxed"><strong className="text-yellow-500 block mb-1">{t.manual_warning}</strong>{t.manual_warning_text}</p></div>
                                <div className="p-6 border-b border-slate-800 flex justify-between items-center"><div><h3 className="text-xl font-bold text-white">{t.ranking_masteries}</h3><p className="text-slate-400 text-sm">{t.ranking_masteries_sub}</p></div><div className="flex bg-slate-800 p-1 rounded-lg border border-slate-700"><button onClick={() => setMasteryViewMode('combined')} className={`px-3 py-1.5 rounded text-xs font-bold transition-colors ${masteryViewMode === 'combined' ? 'bg-blue-600 text-white shadow-sm' : 'text-slate-400 hover:text-white'}`}>{t.combined}</button><button onClick={() => setMasteryViewMode('individual')} className={`px-3 py-1.5 rounded text-xs font-bold transition-colors ${masteryViewMode === 'individual' ? 'bg-blue-600 text-white shadow-sm' : 'text-slate-400 hover:text-white'}`}>{t.individual}</button></div></div>
                                <div className="overflow-x-auto">
                                    <table className="w-full text-left border-collapse">
                                        <thead>
                                            <tr className="bg-slate-950/50 border-b border-slate-800 text-slate-400 text-xs font-bold uppercase tracking-wider"><th className="p-5">#</th><th className="p-5 cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('name')}>{t.mastery} <SortIndicator active={sortConfig.key === 'name'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('players')}>{t.active_players} <SortIndicator active={sortConfig.key === 'players'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('wins')}>{t.total_wins} <SortIndicator active={sortConfig.key === 'wins'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('losses')}>{t.losses} <SortIndicator active={sortConfig.key === 'losses'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('battles')}>{t.battles} <SortIndicator active={sortConfig.key === 'battles'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('winRate')}>{t.win_rate} <SortIndicator active={sortConfig.key === 'winRate'} direction={sortConfig.direction} /></th></tr>
                                        </thead>
                                        <tbody className="divide-y divide-slate-800">
                                            {groupedMasteries.map((m, idx) => (
                                                <tr key={m.name} className="hover:bg-slate-800/50 transition-colors cursor-pointer group" onClick={() => handleMasteryClick(m.name)} title="Clique para ver os jogadores com esta maestria">
                                                    <td className="p-5 text-slate-500 font-bold">{idx + 1}</td>
                                                    <td className="p-5"><div className="flex flex-wrap gap-2">{m.parts.map((part, i) => (<span key={i} className={`text-sm font-bold px-3 py-1 rounded border uppercase tracking-wide group-hover:brightness-110 ${STYLE_MAP[part] || 'text-slate-200 border-slate-700'}`}>{part}</span>))}</div></td>
                                                    <td className="p-5 text-center text-slate-300 font-bold group-hover:text-white">{m.players}</td>
                                                    <td className="p-5 text-center text-yellow-500 font-bold">{m.wins}</td>
                                                    <td className="p-5 text-center text-red-500 font-bold">{m.losses}</td>
                                                    <td className="p-5 text-center text-blue-400 font-bold">{m.battles}</td>
                                                    <td className="p-5 text-center"><span className={`text-xs font-bold px-2 py-1 rounded-full ${parseFloat(m.winRate) >= 60 ? 'bg-green-500/20 text-green-400' : parseFloat(m.winRate) >= 40 ? 'bg-yellow-500/20 text-yellow-400' : 'bg-red-500/20 text-red-400'}`}>{m.winRate}%</span></td>
                                                </tr>
                                            ))}
                                            {groupedMasteries.length === 0 && (<tr><td colSpan="7" className="p-8 text-center text-slate-500">{t.no_mastery_data}</td></tr>)}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}

                        {viewMode === 'villages' && (
                            <div className="bg-slate-900 rounded-2xl shadow-xl overflow-hidden border border-slate-800 animate-in fade-in slide-in-from-bottom-4 duration-500">
                                <div className="bg-slate-900/50 border-b border-yellow-500/20 px-6 py-3 flex items-start gap-3"><AlertCircle className="w-5 h-5 text-yellow-500 flex-shrink-0 mt-0.5" /><p className="text-xs text-slate-400 leading-relaxed"><strong className="text-yellow-500 block mb-1">{t.manual_warning}</strong>{t.manual_warning_text}</p></div>
                                <div className="p-6 border-b border-slate-800"><h3 className="text-xl font-bold text-white">{t.ranking_villages}</h3><p className="text-slate-400 text-sm">{t.ranking_villages_sub}</p></div>
                                <div className="overflow-x-auto">
                                    <table className="w-full text-left border-collapse">
                                        <thead>
                                            <tr className="bg-slate-950/50 border-b border-slate-800 text-slate-400 text-xs font-bold uppercase tracking-wider"><th className="p-5">#</th><th className="p-5 cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('name')}>{t.village} <SortIndicator active={sortConfig.key === 'name'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('players')}>{t.active_players} <SortIndicator active={sortConfig.key === 'players'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('wins')}>{t.total_wins} <SortIndicator active={sortConfig.key === 'wins'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('losses')}>{t.losses} <SortIndicator active={sortConfig.key === 'losses'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('battles')}>{t.battles} <SortIndicator active={sortConfig.key === 'battles'} direction={sortConfig.direction} /></th><th className="p-5 text-center cursor-pointer hover:text-white transition-colors" onClick={() => handleSort('winRate')}>{t.win_rate} <SortIndicator active={sortConfig.key === 'winRate'} direction={sortConfig.direction} /></th></tr>
                                        </thead>
                                        <tbody className="divide-y divide-slate-800">
                                            {groupedVillages.map((v, idx) => (
                                                <tr key={v.name} className="hover:bg-slate-800/50 transition-colors cursor-pointer group" onClick={() => handleVillageClick(v.name)} title="Clique para ver os jogadores desta vila">
                                                    <td className="p-5 text-slate-500 font-bold">{idx + 1}</td>
                                                    <td className="p-5 font-bold text-lg"><span className={STYLE_MAP[v.name] || 'text-white'}>{v.name}</span></td>
                                                    <td className="p-5 text-center text-slate-300 font-bold">{v.players}</td>
                                                    <td className="p-5 text-center text-yellow-500 font-bold">{v.wins}</td>
                                                    <td className="p-5 text-center text-red-500 font-bold">{v.losses}</td>
                                                    <td className="p-5 text-center text-blue-400 font-bold">{v.battles}</td>
                                                    <td className="p-5 text-center"><span className={`text-xs font-bold px-2 py-1 rounded-full ${parseFloat(v.winRate) >= 60 ? 'bg-green-500/20 text-green-400' : parseFloat(v.winRate) >= 40 ? 'bg-yellow-500/20 text-yellow-400' : 'bg-red-500/20 text-red-400'}`}>{v.winRate}%</span></td>
                                                </tr>
                                            ))}
                                            {groupedVillages.length === 0 && (<tr><td colSpan="7" className="p-8 text-center text-slate-500">{t.no_village_data}</td></tr>)}
                                        </tbody>
                                    </table>
                                </div>
                            </div>
                        )}
                        
                        <div className="text-center text-[10px] text-slate-700 mt-8 pb-4">{t.files_loaded}: {loadedFilesCount}</div>
                    </div>
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
